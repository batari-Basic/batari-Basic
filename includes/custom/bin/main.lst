ARM GAS  main.s 			page 1


   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.my_memcpy,"ax",%progbits
  18              		.align	1
  19              		.global	my_memcpy
  20              		.code	16
  21              		.thumb_func
  23              	my_memcpy:
  24              	.LFB0:
  25              		.file 1 "main.c"
   1:main.c        **** // src/custom.h defines the following:
   2:main.c        **** //
   3:main.c        **** // queue[]     - points to the 4K Display Data Bank
   4:main.c        **** //             - treat as RAM
   5:main.c        **** //             - Any data passed to/from the ARM and 6507 must be done via queue[]
   6:main.c        **** //
   7:main.c        **** // flashdata[] - points to the 24K that comprises the six 4K banks.
   8:main.c        **** //             - treat as ROM
   9:main.c        **** #include "src/custom.h"
  10:main.c        ****
  11:main.c        ****
  12:main.c        **** // types of variables, storage used and range
  13:main.c        **** // const              = constant, which is compiled into the ROM section and cannot be changed duri
  14:main.c        **** // char               =  8 bit, 1 byte  per value.  Range is           -128 to           127
  15:main.c        **** // unsigned char      =  8 bit, 1 byte  per value.  Range is              0 to           255
  16:main.c        **** // short int          = 16 bit, 2 bytes per value.  Range is        -32,768 to        32,767
  17:main.c        **** // unsigned short int = 16 bit, 2 bytes per value.  Range is              0 to        65,535
  18:main.c        **** // int                = 32 bit, 4 bytes per value.  Range is -2,147,483,648 to 2,147,483,647
  19:main.c        **** // unsigned int       = 32 bit, 4 bytes per value.  Range is              0 to 4,294,967,295
  20:main.c        **** // long int           = same as int
  21:main.c        **** // float              = 32 bit, 4 bytes.  Not Supported#
  22:main.c        **** // double             = 64 bit, 8 bytes.  Not Supported#
  23:main.c        **** // *                  = 32 bit, 4 bytes, pointer (ie: char*, int*)
  24:main.c        **** //
  25:main.c        **** // # - at least not supported with the compiler under OS X.  It might be supported by the Linux/Win
  26:main.c        **** //     compiler - but support would be implemented via software as the ARM in the Harmony Cartridge
  27:main.c        **** //     have an FPU (floating point unit).  As such, performance will most likely be as good as usin
  28:main.c        **** //     integer math based routines.
  29:main.c        **** //
  30:main.c        **** // NOTE : Only 448 bytes are allocated for use by variables (the rest of the 512 byte section is us
  31:main.c        **** //        as the stack).  If you use too many variables, you'll get a compile time error:  "region
  32:main.c        **** //        You can use RAM in the Display Data to store values, see defines.h for queue[xxx] defines
  33:main.c        **** //
ARM GAS  main.s 			page 2


  34:main.c        **** // NOTE : Compiled code can be significantly smaller if you use INTs for your variables instead of
  35:main.c        **** //        SHORTs or CHARs.
  36:main.c        ****
  37:main.c        **** volatile unsigned char *queue=(unsigned char *)0x40000C00;
  38:main.c        **** volatile unsigned char *flashdata=(unsigned char *)0x0C00;
  39:main.c        **** volatile int *queue_int=(int *)0x40000C00;
  40:main.c        **** enum {
  41:main.c        **** SpriteGfxIndex,
  42:main.c        **** junk1,
  43:main.c        **** junk2,
  44:main.c        **** junk3,
  45:main.c        **** junk4, // placeholders
  46:main.c        **** junk5a, // placeholders
  47:main.c        **** junk6a, // placeholders
  48:main.c        **** junk78, // placeholders
  49:main.c        **** junk8a, // placeholders
  50:main.c        **** spritedisplay,
  51:main.c        **** player0x,
  52:main.c        **** player1x,
  53:main.c        **** player2x,
  54:main.c        **** player3x,
  55:main.c        **** player4x,
  56:main.c        **** player5x,
  57:main.c        **** player6x,
  58:main.c        **** player7x,
  59:main.c        **** player8x,
  60:main.c        **** player9x,
  61:main.c        **** player0y,
  62:main.c        **** player1y,
  63:main.c        **** player2y,
  64:main.c        **** player3y,
  65:main.c        **** player4y,
  66:main.c        **** player5y,
  67:main.c        **** player6y,
  68:main.c        **** player7y,
  69:main.c        **** player8y,
  70:main.c        **** player9y,
  71:main.c        **** player0color, junk5,
  72:main.c        **** player0height,
  73:main.c        **** player1height,
  74:main.c        **** player2height,
  75:main.c        **** player3height,
  76:main.c        **** player4height,
  77:main.c        **** player5height,
  78:main.c        **** player6height,
  79:main.c        **** player7height,
  80:main.c        **** player8height,
  81:main.c        **** player9height,
  82:main.c        **** _NUSIZ1,
  83:main.c        **** NUSIZ2,
  84:main.c        **** NUSIZ3,
  85:main.c        **** NUSIZ4,
  86:main.c        **** NUSIZ5,
  87:main.c        **** NUSIZ6,
  88:main.c        **** NUSIZ7,
  89:main.c        **** NUSIZ8,
  90:main.c        **** NUSIZ9,
ARM GAS  main.s 			page 3


  91:main.c        **** score,score2,score3,
  92:main.c        **** COLUM0,
  93:main.c        **** COLUM1,
  94:main.c        **** player0pointerlo,
  95:main.c        **** player0pointerhi,
  96:main.c        **** // end of RAM, start of playerpointers
  97:main.c        **** player1pointerlo,
  98:main.c        **** player1pointerhi,
  99:main.c        **** player2pointerlo,
 100:main.c        **** player2pointerhi,
 101:main.c        **** player3pointerlo,
 102:main.c        **** player3pointerhi,
 103:main.c        **** player4pointerlo,
 104:main.c        **** player4pointerhi,
 105:main.c        **** player5pointerlo,
 106:main.c        **** player5pointerhi,
 107:main.c        **** player6pointerlo,
 108:main.c        **** player6pointerhi,
 109:main.c        **** player7pointerlo,
 110:main.c        **** player7pointerhi,
 111:main.c        **** player8pointerlo,
 112:main.c        **** player8pointerhi,
 113:main.c        **** player9pointerlo,
 114:main.c        **** player9pointerhi,
 115:main.c        **** player1color, junk6,
 116:main.c        **** player2color, junk7,
 117:main.c        **** player3color, junk8,
 118:main.c        **** player4color, junk9,
 119:main.c        **** player5color, junk10,
 120:main.c        **** player6color, junk11,
 121:main.c        **** player7color, junk12,
 122:main.c        **** player8color, junk13,
 123:main.c        **** player9color, junk14
 124:main.c        **** };
 125:main.c        ****
 126:main.c        ****  enum {SKIP,OVERLAP,NOOVERLAP};
 127:main.c        ****
 128:main.c        **** // global variables are those found outside of any function.  They can be used by any function.
 129:main.c        **** // The Harmony Cartridge preserves these values for you between ARM code calls.
 130:main.c        ****
 131:main.c        **** unsigned char *C_function=(unsigned int *)(0x40000C00 + 0x1A4);
 132:main.c        **** unsigned short *fetcher_address_table=(unsigned short *)(0xC00 + 0x61A0);
 133:main.c        **** unsigned char *RIOT=(unsigned char *)(0x40000C00 + 0x1A8);
 134:main.c        **** //unsigned char *HMdiv=(unsigned char *)(0xc00+0x1000);
 135:main.c        **** unsigned char *fetcheraddr;
 136:main.c        **** unsigned char *pfpixel;
 137:main.c        **** int count;
 138:main.c        **** //int Gfxindex;
 139:main.c        **** //signed int temp1;
 140:main.c        **** //int temp2;
 141:main.c        **** //int temp3;
 142:main.c        **** int temp4;
 143:main.c        **** int temp5;
 144:main.c        **** unsigned int mask;
 145:main.c        ****
 146:main.c        ****  // masking: NUSIZ bit 7=off/on, NUSIZ 6=L/R
 147:main.c        ****  // REVENG - no-mask entries replaced by later if...then which is a bit smaller.
ARM GAS  main.s 			page 4


 148:main.c        ****  //          in their place is masking for reflected sprites.
 149:main.c        **** const unsigned char maskdata[32]=
 150:main.c        **** 	{
 151:main.c        **** 	 0,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,
 152:main.c        **** 	 0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0,
 153:main.c        ****          0,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
 154:main.c        ****          0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,0
 155:main.c        ****           };
 156:main.c        ****
 157:main.c        **** char spritesort[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 0};
 158:main.c        **** char myGfxIndex[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 0};
 159:main.c        ****
 160:main.c        **** // REVENG - changed maxsprites to a variable value, so unused sprite memory can be claimed
 161:main.c        **** char maxsprites;
 162:main.c        ****
 163:main.c        **** #define    kernello(a) fetcheraddr[(a)]
 164:main.c        **** #define    kernelhi(a) fetcheraddr[(a)+11]
 165:main.c        **** #define    dflow(a) fetcheraddr[(a)+22]
 166:main.c        **** #define    dfhigh(a)  fetcheraddr[(a)+30]
 167:main.c        **** #define    dffraclo(a)  fetcheraddr[(a)+38]
 168:main.c        **** #define    dffrachi(a)  fetcheraddr[(a)+46]
 169:main.c        **** #define    scoregraphics(a)  fetcheraddr[(a)+54]
 170:main.c        **** #define    scorepointer(a)  fetcheraddr[(a)+56]
 171:main.c        **** #define    Hmval(a)  fetcheraddr[(a)+58]
 172:main.c        **** #define    Hmval74(a)  fetcheraddr[(a)+66]
 173:main.c        ****
 174:main.c        **** void my_memcpy(unsigned char* destination, unsigned char* source, int offset, int count)
 175:main.c        **** {
  26              		.loc 1 175 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 20
  32              		.cfi_offset 4, -20
  33              		.cfi_offset 5, -16
  34              		.cfi_offset 6, -12
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
 176:main.c        ****         int i; //saves a few bytes
 177:main.c        ****         for(i=0;i<count;i++)
  37              		.loc 1 177 0
  38 0002 141C     		mov	r4, r2
  39              	.LVL1:
  40              	.L2:
 174:main.c        **** void my_memcpy(unsigned char* destination, unsigned char* source, int offset, int count)
  41              		.loc 1 174 0 discriminator 1
  42 0004 A51A     		sub	r5, r4, r2
  43              		.loc 1 177 0 discriminator 1
  44 0006 9D42     		cmp	r5, r3
  45 0008 09DA     		bge	.L5
  46              	.L3:
 178:main.c        ****                 destination[(i+offset)&255] = source[i]&mask;
  47              		.loc 1 178 0 discriminator 2
  48 000a 064F     		ldr	r7, .L6
 174:main.c        **** void my_memcpy(unsigned char* destination, unsigned char* source, int offset, int count)
  49              		.loc 1 174 0 discriminator 2
ARM GAS  main.s 			page 5


  50 000c 8E1A     		sub	r6, r1, r2
  51              		.loc 1 178 0 discriminator 2
  52 000e 365D     		ldrb	r6, [r6, r4]
  53 0010 3F68     		ldr	r7, [r7]
  54 0012 2506     		lsl	r5, r4, #24
  55 0014 2D0E     		lsr	r5, r5, #24
  56 0016 3E40     		and	r6, r7
  57 0018 4655     		strb	r6, [r0, r5]
  58 001a 0134     		add	r4, r4, #1
  59 001c F2E7     		b	.L2
  60              	.L5:
 179:main.c        **** }
  61              		.loc 1 179 0
  62              		@ sp needed for prologue
  63 001e F0BC     		pop	{r4, r5, r6, r7}
  64 0020 01BC     		pop	{r0}
  65 0022 0047     		bx	r0
  66              	.L7:
  67              		.align	2
  68              	.L6:
  69 0024 00000000 		.word	mask
  70              		.cfi_endproc
  71              	.LFE0:
  73              		.section	.text.my_memset,"ax",%progbits
  74              		.align	1
  75              		.global	my_memset
  76              		.code	16
  77              		.thumb_func
  79              	my_memset:
  80              	.LFB1:
 180:main.c        ****
 181:main.c        **** void my_memset(unsigned char* destination, int fill_value, int count)
 182:main.c        **** {
  81              		.loc 1 182 0
  82              		.cfi_startproc
  83              	.LVL2:
  84 0000 10B5     		push	{r4, lr}
  85              	.LCFI1:
  86              		.cfi_def_cfa_offset 8
  87              		.cfi_offset 4, -8
  88              		.cfi_offset 14, -4
 183:main.c        ****         int i; //saves a few bytes
 184:main.c        ****         for (i=0;i<count;i++)
  89              		.loc 1 184 0
  90 0002 031C     		mov	r3, r0
  91              	.LVL3:
  92              	.L9:
 181:main.c        **** void my_memset(unsigned char* destination, int fill_value, int count)
  93              		.loc 1 181 0 discriminator 1
  94 0004 1C1A     		sub	r4, r3, r0
  95              		.loc 1 184 0 discriminator 1
  96 0006 9442     		cmp	r4, r2
  97 0008 02DA     		bge	.L11
  98              	.L10:
 185:main.c        ****                 destination[i]=fill_value;
  99              		.loc 1 185 0 discriminator 2
 100 000a 1970     		strb	r1, [r3]
ARM GAS  main.s 			page 6


 101 000c 0133     		add	r3, r3, #1
 102 000e F9E7     		b	.L9
 103              	.L11:
 186:main.c        **** }
 104              		.loc 1 186 0
 105              		@ sp needed for prologue
 106 0010 10BC     		pop	{r4}
 107 0012 01BC     		pop	{r0}
 108 0014 0047     		bx	r0
 109              		.cfi_endproc
 110              	.LFE1:
 112              		.section	.text.reverse,"ax",%progbits
 113              		.align	1
 114              		.global	reverse
 115              		.code	16
 116              		.thumb_func
 118              	reverse:
 119              	.LFB2:
 187:main.c        ****
 188:main.c        **** void reverse(int i, int j, unsigned char* x)
 189:main.c        **** {
 120              		.loc 1 189 0
 121              		.cfi_startproc
 122              	.LVL4:
 123 0000 10B5     		push	{r4, lr}
 124              	.LCFI2:
 125              		.cfi_def_cfa_offset 8
 126              		.cfi_offset 4, -8
 127              		.cfi_offset 14, -4
 128              	.L13:
 190:main.c        ****         int t;
 191:main.c        ****         while (i < j)
 129              		.loc 1 191 0 discriminator 1
 130 0002 8842     		cmp	r0, r1
 131 0004 06DA     		bge	.L15
 132              	.L14:
 192:main.c        ****         {
 193:main.c        ****               t = x[i]; x[i] = x[j]; x[j] = t;
 133              		.loc 1 193 0
 134 0006 135C     		ldrb	r3, [r2, r0]
 135              	.LVL5:
 136 0008 545C     		ldrb	r4, [r2, r1]
 137 000a 1454     		strb	r4, [r2, r0]
 138 000c 5354     		strb	r3, [r2, r1]
 194:main.c        ****               i++;
 139              		.loc 1 194 0
 140 000e 0130     		add	r0, r0, #1
 141              	.LVL6:
 195:main.c        ****               j--;
 142              		.loc 1 195 0
 143 0010 0139     		sub	r1, r1, #1
 144              	.LVL7:
 145 0012 F6E7     		b	.L13
 146              	.LVL8:
 147              	.L15:
 196:main.c        ****         }
 197:main.c        **** }
ARM GAS  main.s 			page 7


 148              		.loc 1 197 0
 149              		@ sp needed for prologue
 150 0014 10BC     		pop	{r4}
 151 0016 01BC     		pop	{r0}
 152 0018 0047     		bx	r0
 153              		.cfi_endproc
 154              	.LFE2:
 156              		.section	.text.memscroll,"ax",%progbits
 157              		.align	1
 158              		.global	memscroll
 159              		.code	16
 160              		.thumb_func
 162              	memscroll:
 163              	.LFB3:
 198:main.c        ****
 199:main.c        **** void memscroll(unsigned char* qmemory, unsigned char offset)
 200:main.c        **** {
 164              		.loc 1 200 0
 165              		.cfi_startproc
 166              	.LVL9:
 167 0000 38B5     		push	{r3, r4, r5, lr}
 168              	.LCFI3:
 169              		.cfi_def_cfa_offset 16
 170              		.cfi_offset 3, -16
 171              		.cfi_offset 4, -12
 172              		.cfi_offset 5, -8
 173              		.cfi_offset 14, -4
 174              		.loc 1 200 0
 175 0002 041C     		mov	r4, r0
 176 0004 0D1C     		mov	r5, r1
 201:main.c        ****         // REVENG - the classic "shift N elements through reversal" algorithm
 202:main.c        ****         reverse(0,offset-1,qmemory);
 177              		.loc 1 202 0
 178 0006 221C     		mov	r2, r4
 179 0008 0139     		sub	r1, r1, #1
 180              	.LVL10:
 181 000a 0020     		mov	r0, #0
 182              	.LVL11:
 183 000c FFF7FEFF 		bl	reverse
 184              	.LVL12:
 203:main.c        ****         reverse(offset,255,qmemory);
 185              		.loc 1 203 0
 186 0010 281C     		mov	r0, r5
 187 0012 221C     		mov	r2, r4
 188 0014 FF21     		mov	r1, #255
 189 0016 FFF7FEFF 		bl	reverse
 190              	.LVL13:
 204:main.c        ****         reverse(0,255,qmemory);
 191              		.loc 1 204 0
 192 001a 0020     		mov	r0, #0
 193 001c FF21     		mov	r1, #255
 194 001e 221C     		mov	r2, r4
 195 0020 FFF7FEFF 		bl	reverse
 196              	.LVL14:
 205:main.c        **** }
 197              		.loc 1 205 0
 198              		@ sp needed for prologue
ARM GAS  main.s 			page 8


 199              	.LVL15:
 200 0024 38BC     		pop	{r3, r4, r5}
 201 0026 01BC     		pop	{r0}
 202 0028 0047     		bx	r0
 203              		.cfi_endproc
 204              	.LFE3:
 206              		.section	.text.get32bitdff,"ax",%progbits
 207              		.align	1
 208              		.global	get32bitdff
 209              		.code	16
 210              		.thumb_func
 212              	get32bitdff:
 213              	.LFB4:
 206:main.c        ****
 207:main.c        **** unsigned int get32bitdff(int offset)
 208:main.c        **** {
 214              		.loc 1 208 0
 215              		.cfi_startproc
 216              	.LVL16:
 209:main.c        ****   return((dffrachi(offset)<<8)+dffraclo(offset));
 217              		.loc 1 209 0
 218 0000 054B     		ldr	r3, .L18
 219 0002 1B68     		ldr	r3, [r3]
 220 0004 1B18     		add	r3, r3, r0
 221 0006 1A1C     		mov	r2, r3
 222 0008 2E32     		add	r2, r2, #46
 223 000a 1078     		ldrb	r0, [r2]
 224              	.LVL17:
 225 000c 2633     		add	r3, r3, #38
 226 000e 1B78     		ldrb	r3, [r3]
 227 0010 0002     		lsl	r0, r0, #8
 228 0012 C018     		add	r0, r0, r3
 210:main.c        **** }
 229              		.loc 1 210 0
 230              		@ sp needed for prologue
 231 0014 7047     		bx	lr
 232              	.L19:
 233 0016 C046     		.align	2
 234              	.L18:
 235 0018 00000000 		.word	fetcheraddr
 236              		.cfi_endproc
 237              	.LFE4:
 239              		.section	.text.get32bitdf,"ax",%progbits
 240              		.align	1
 241              		.global	get32bitdf
 242              		.code	16
 243              		.thumb_func
 245              	get32bitdf:
 246              	.LFB5:
 211:main.c        ****
 212:main.c        **** unsigned int get32bitdf(int offset)
 213:main.c        **** {
 247              		.loc 1 213 0
 248              		.cfi_startproc
 249              	.LVL18:
 214:main.c        ****   return((dfhigh(offset)<<8)+dflow(offset));
 250              		.loc 1 214 0
ARM GAS  main.s 			page 9


 251 0000 034B     		ldr	r3, .L21
 252 0002 1B68     		ldr	r3, [r3]
 253 0004 1B18     		add	r3, r3, r0
 254 0006 987F     		ldrb	r0, [r3, #30]
 255              	.LVL19:
 256 0008 9B7D     		ldrb	r3, [r3, #22]
 257 000a 0002     		lsl	r0, r0, #8
 258 000c C018     		add	r0, r0, r3
 215:main.c        **** }
 259              		.loc 1 215 0
 260              		@ sp needed for prologue
 261 000e 7047     		bx	lr
 262              	.L22:
 263              		.align	2
 264              	.L21:
 265 0010 00000000 		.word	fetcheraddr
 266              		.cfi_endproc
 267              	.LFE5:
 269              		.section	.text.shiftnumbers,"ax",%progbits
 270              		.align	1
 271              		.global	shiftnumbers
 272              		.code	16
 273              		.thumb_func
 275              	shiftnumbers:
 276              	.LFB6:
 216:main.c        ****
 217:main.c        **** void shiftnumbers(int xreg)
 218:main.c        **** {
 277              		.loc 1 218 0
 278              		.cfi_startproc
 279              	.LVL20:
 219:main.c        ****   while (xreg!=maxsprites-1)
 280              		.loc 1 219 0
 281 0000 064B     		ldr	r3, .L27
 282 0002 1A78     		ldrb	r2, [r3]
 283 0004 013A     		sub	r2, r2, #1
 284              	.L24:
 285              		.loc 1 219 0 is_stmt 0 discriminator 1
 286 0006 9042     		cmp	r0, r2
 287 0008 06D0     		beq	.L26
 288              	.L25:
 220:main.c        ****   {
 221:main.c        ****     myGfxIndex[xreg]=myGfxIndex[xreg+1];
 289              		.loc 1 221 0 is_stmt 1
 290 000a 054B     		ldr	r3, .L27+4
 291 000c 0130     		add	r0, r0, #1
 292              	.LVL21:
 293 000e C15C     		ldrb	r1, [r0, r3]
 217:main.c        **** void shiftnumbers(int xreg)
 294              		.loc 1 217 0
 295 0010 1B18     		add	r3, r3, r0
 296 0012 013B     		sub	r3, r3, #1
 297              		.loc 1 221 0
 298 0014 1970     		strb	r1, [r3]
 299              	.LVL22:
 300 0016 F6E7     		b	.L24
 301              	.L26:
ARM GAS  main.s 			page 10


 222:main.c        ****     xreg++;
 223:main.c        ****   }
 224:main.c        ****
 225:main.c        **** }
 302              		.loc 1 225 0
 303              		@ sp needed for prologue
 304 0018 7047     		bx	lr
 305              	.L28:
 306 001a C046     		.align	2
 307              	.L27:
 308 001c 00000000 		.word	maxsprites
 309 0020 00000000 		.word	.LANCHOR0
 310              		.cfi_endproc
 311              	.LFE6:
 313              		.section	.text.checkwrap,"ax",%progbits
 314              		.align	1
 315              		.global	checkwrap
 316              		.code	16
 317              		.thumb_func
 319              	checkwrap:
 320              	.LFB7:
 226:main.c        ****
 227:main.c        **** char checkwrap(char a, char b)
 228:main.c        **** {
 321              		.loc 1 228 0
 322              		.cfi_startproc
 323              	.LVL23:
 229:main.c        ****   if (((a+b)&255)<b) return 0;
 324              		.loc 1 229 0
 325 0000 4318     		add	r3, r0, r1
 228:main.c        **** {
 326              		.loc 1 228 0
 327 0002 10B5     		push	{r4, lr}
 328              	.LCFI4:
 329              		.cfi_def_cfa_offset 8
 330              		.cfi_offset 4, -8
 331              		.cfi_offset 14, -4
 332              		.loc 1 229 0
 333 0004 1B06     		lsl	r3, r3, #24
 334 0006 1B0E     		lsr	r3, r3, #24
 335 0008 DC17     		asr	r4, r3, #31
 336 000a CA0F     		lsr	r2, r1, #31
 337 000c 8B42     		cmp	r3, r1
 338 000e 5441     		adc	r4, r4, r2
 339 0010 6342     		neg	r3, r4
 340 0012 1840     		and	r0, r3
 341              	.LVL24:
 230:main.c        ****   return a;
 231:main.c        **** }
 342              		.loc 1 231 0
 343              		@ sp needed for prologue
 344 0014 10BC     		pop	{r4}
 345 0016 02BC     		pop	{r1}
 346 0018 0847     		bx	r1
 347              		.cfi_endproc
 348              	.LFE7:
 350              		.section	.text.checkswap,"ax",%progbits
ARM GAS  main.s 			page 11


 351              		.align	1
 352              		.global	checkswap
 353              		.code	16
 354              		.thumb_func
 356              	checkswap:
 357              	.LFB8:
 232:main.c        ****
 233:main.c        **** int checkswap(int a, int b)
 234:main.c        **** {
 358              		.loc 1 234 0
 359              		.cfi_startproc
 360              	.LVL25:
 361 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 362              	.LCFI5:
 363              		.cfi_def_cfa_offset 20
 364              		.cfi_offset 4, -20
 365              		.cfi_offset 5, -16
 366              		.cfi_offset 6, -12
 367              		.cfi_offset 7, -8
 368              		.cfi_offset 14, -4
 235:main.c        ****   signed int temp1;
 236:main.c        ****   char s1,s2;
 237:main.c        ****   s1=checkwrap(RIOT[player1y+a],RIOT[player1height+a]);
 369              		.loc 1 237 0
 370 0002 154B     		ldr	r3, .L37
 371 0004 DA68     		ldr	r2, [r3, #12]
 372 0006 1018     		add	r0, r2, r0
 373              	.LVL26:
 374 0008 447D     		ldrb	r4, [r0, #21]
 375              	.LVL27:
 376 000a 2130     		add	r0, r0, #33
 377              	.LVL28:
 378              	.LBB6:
 379              	.LBB7:
 229:main.c        ****   if (((a+b)&255)<b) return 0;
 380              		.loc 1 229 0
 381 000c 0378     		ldrb	r3, [r0]
 382 000e FF20     		mov	r0, #255
 383              	.LVL29:
 384 0010 E518     		add	r5, r4, r3
 385 0012 0540     		and	r5, r0
 386 0014 EF17     		asr	r7, r5, #31
 387 0016 DE0F     		lsr	r6, r3, #31
 388 0018 9D42     		cmp	r5, r3
 389 001a 7741     		adc	r7, r7, r6
 390              	.LBE7:
 391              	.LBE6:
 238:main.c        ****   s2=checkwrap(RIOT[player1y+b],RIOT[player1height+b]);
 392              		.loc 1 238 0
 393 001c 5118     		add	r1, r2, r1
 394              	.LVL30:
 395 001e 4A7D     		ldrb	r2, [r1, #21]
 396              	.LVL31:
 397              	.LBB10:
 398              	.LBB8:
 229:main.c        ****   if (((a+b)&255)<b) return 0;
 399              		.loc 1 229 0
ARM GAS  main.s 			page 12


 400 0020 7B42     		neg	r3, r7
 401              	.LBE8:
 402              	.LBE10:
 403              		.loc 1 238 0
 404 0022 2131     		add	r1, r1, #33
 405              	.LBB11:
 406              	.LBB9:
 229:main.c        ****   if (((a+b)&255)<b) return 0;
 407              		.loc 1 229 0
 408 0024 1C40     		and	r4, r3
 409              	.LVL32:
 410              	.LBE9:
 411              	.LBE11:
 412              	.LBB12:
 413              	.LBB13:
 414 0026 0B78     		ldrb	r3, [r1]
 415 0028 D118     		add	r1, r2, r3
 416              	.LVL33:
 417 002a 0140     		and	r1, r0
 418 002c CD17     		asr	r5, r1, #31
 419 002e D80F     		lsr	r0, r3, #31
 420 0030 9942     		cmp	r1, r3
 421 0032 4541     		adc	r5, r5, r0
 422 0034 6942     		neg	r1, r5
 423 0036 0A40     		and	r2, r1
 424              	.LBE13:
 425              	.LBE12:
 239:main.c        ****   temp1=s1-s2;
 426              		.loc 1 239 0
 427 0038 A21A     		sub	r2, r4, r2
 428              	.LVL34:
 240:main.c        ****   if (temp1>0)
 429              		.loc 1 240 0
 430 003a 002A     		cmp	r2, #0
 431 003c 07DD     		ble	.L36
 241:main.c        ****   { // larger is higher
 242:main.c        ****     if ((temp1-=5)>0)
 432              		.loc 1 242 0
 433 003e 053A     		sub	r2, r2, #5
 434              	.LVL35:
 435 0040 002A     		cmp	r2, #0
 436 0042 04DD     		ble	.L36
 243:main.c        ****     {// not overlapping
 244:main.c        ****       if (temp1>RIOT[player1height+b])
 437              		.loc 1 244 0
 438 0044 D00F     		lsr	r0, r2, #31
 439 0046 D917     		asr	r1, r3, #31
 440 0048 9342     		cmp	r3, r2
 441 004a 4841     		adc	r0, r0, r1
 442 004c 00E0     		b	.L34
 443              	.L36:
 245:main.c        **** 	return SKIP;
 246:main.c        ****       else return OVERLAP;
 247:main.c        ****     }
 248:main.c        ****     else
 249:main.c        ****       return OVERLAP;
 250:main.c        ****   }
ARM GAS  main.s 			page 13


 251:main.c        ****   else // largerXislower
 252:main.c        ****   {
 253:main.c        ****     if ((temp1=(temp1^0xFF)-5)>0)
 254:main.c        ****       return OVERLAP;
 444              		.loc 1 254 0
 445 004e 0120     		mov	r0, #1
 446              	.L34:
 255:main.c        ****     else
 256:main.c        ****     {//notoverlapping
 257:main.c        ****       if (temp1>RIOT[player1height+b])
 258:main.c        ****         return NOOVERLAP;
 259:main.c        ****       else return OVERLAP;
 260:main.c        ****     }
 261:main.c        ****   }
 262:main.c        **** }
 447              		.loc 1 262 0
 448              		@ sp needed for prologue
 449 0050 F0BC     		pop	{r4, r5, r6, r7}
 450 0052 02BC     		pop	{r1}
 451 0054 0847     		bx	r1
 452              	.L38:
 453 0056 C046     		.align	2
 454              	.L37:
 455 0058 00000000 		.word	.LANCHOR0
 456              		.cfi_endproc
 457              	.LFE8:
 459              		.section	.text.copynybble,"ax",%progbits
 460              		.align	1
 461              		.global	copynybble
 462              		.code	16
 463              		.thumb_func
 465              	copynybble:
 466              	.LFB9:
 263:main.c        ****
 264:main.c        **** void copynybble(unsigned char num)
 265:main.c        **** {
 467              		.loc 1 265 0
 468              		.cfi_startproc
 469              	.LVL36:
 266:main.c        ****     int i;
 267:main.c        ****     unsigned char *destination;
 268:main.c        ****     unsigned char *source;
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 470              		.loc 1 269 0
 471 0000 154B     		ldr	r3, .L41
 265:main.c        **** {
 472              		.loc 1 265 0
 473 0002 70B5     		push	{r4, r5, r6, lr}
 474              	.LCFI6:
 475              		.cfi_def_cfa_offset 16
 476              		.cfi_offset 4, -16
 477              		.cfi_offset 5, -12
 478              		.cfi_offset 6, -8
 479              		.cfi_offset 14, -4
 480              		.loc 1 269 0
 481 0004 154C     		ldr	r4, .L41+4
 482 0006 1B68     		ldr	r3, [r3]
ARM GAS  main.s 			page 14


 483 0008 2268     		ldr	r2, [r4]
 484 000a 1D1C     		mov	r5, r3
 485 000c D600     		lsl	r6, r2, #3
 486 000e 3835     		add	r5, r5, #56
 487 0010 0132     		add	r2, r2, #1
 488 0012 2260     		str	r2, [r4]
 489 0014 2D78     		ldrb	r5, [r5]
 270:main.c        ****     source=flashdata+(scoregraphics(1)<<8)+scoregraphics(0)+((num&0x0F)<<3);
 490              		.loc 1 270 0
 491 0016 1A1C     		mov	r2, r3
 492 0018 3732     		add	r2, r2, #55
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 493              		.loc 1 269 0
 494 001a 7519     		add	r5, r6, r5
 495              		.loc 1 270 0
 496 001c 1478     		ldrb	r4, [r2]
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 497              		.loc 1 269 0
 498 001e 1E1C     		mov	r6, r3
 499              		.loc 1 270 0
 500 0020 3633     		add	r3, r3, #54
 501 0022 1A78     		ldrb	r2, [r3]
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 502              		.loc 1 269 0
 503 0024 3936     		add	r6, r6, #57
 504              		.loc 1 270 0
 505 0026 2402     		lsl	r4, r4, #8
 506 0028 A318     		add	r3, r4, r2
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 507              		.loc 1 269 0
 508 002a 3678     		ldrb	r6, [r6]
 509              		.loc 1 270 0
 510 002c 0F22     		mov	r2, #15
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 511              		.loc 1 269 0
 512 002e 0C49     		ldr	r1, .L41+8
 513              		.loc 1 270 0
 514 0030 1040     		and	r0, r2
 515              	.LVL37:
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 516              		.loc 1 269 0
 517 0032 3602     		lsl	r6, r6, #8
 518              		.loc 1 270 0
 519 0034 C000     		lsl	r0, r0, #3
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 520              		.loc 1 269 0
 521 0036 AD19     		add	r5, r5, r6
 522              		.loc 1 270 0
 523 0038 1818     		add	r0, r3, r0
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 524              		.loc 1 269 0
 525 003a 0E69     		ldr	r6, [r1, #16]
 526              		.loc 1 270 0
 527 003c 4B69     		ldr	r3, [r1, #20]
 269:main.c        ****     destination=queue+(scorepointer(1)<<8)+scorepointer(0)+((temp5++)<<3);
 528              		.loc 1 269 0
 529 003e 7519     		add	r5, r6, r5
ARM GAS  main.s 			page 15


 530              	.LVL38:
 531              		.loc 1 270 0
 532 0040 1818     		add	r0, r3, r0
 533              	.LVL39:
 271:main.c        ****         for(i=0;i<8;i++)
 534              		.loc 1 271 0
 535 0042 0023     		mov	r3, #0
 536              	.LVL40:
 537              	.L40:
 264:main.c        **** void copynybble(unsigned char num)
 538              		.loc 1 264 0 discriminator 2
 539 0044 C21A     		sub	r2, r0, r3
 272:main.c        ****                 destination[i] = source[7-i];
 540              		.loc 1 272 0 discriminator 2
 541 0046 D279     		ldrb	r2, [r2, #7]
 542 0048 EA54     		strb	r2, [r5, r3]
 271:main.c        ****         for(i=0;i<8;i++)
 543              		.loc 1 271 0 discriminator 2
 544 004a 0133     		add	r3, r3, #1
 545              	.LVL41:
 546 004c 082B     		cmp	r3, #8
 547 004e F9D1     		bne	.L40
 273:main.c        ****
 274:main.c        **** }
 548              		.loc 1 274 0
 549              		@ sp needed for prologue
 550              	.LVL42:
 551              	.LVL43:
 552 0050 70BC     		pop	{r4, r5, r6}
 553 0052 01BC     		pop	{r0}
 554 0054 0047     		bx	r0
 555              	.L42:
 556 0056 C046     		.align	2
 557              	.L41:
 558 0058 00000000 		.word	fetcheraddr
 559 005c 00000000 		.word	temp5
 560 0060 00000000 		.word	.LANCHOR0
 561              		.cfi_endproc
 562              	.LFE9:
 564              		.section	.text.on_off_flip,"ax",%progbits
 565              		.align	1
 566              		.global	on_off_flip
 567              		.code	16
 568              		.thumb_func
 570              	on_off_flip:
 571              	.LFB10:
 275:main.c        ****
 276:main.c        **** void on_off_flip(unsigned int loc, unsigned int fnmask)
 277:main.c        **** {
 572              		.loc 1 277 0
 573              		.cfi_startproc
 574              	.LVL44:
 278:main.c        ****   switch(C_function[0]&3)
 575              		.loc 1 278 0
 576 0000 0F4B     		ldr	r3, .L49
 577 0002 9B69     		ldr	r3, [r3, #24]
 578 0004 1A78     		ldrb	r2, [r3]
ARM GAS  main.s 			page 16


 579 0006 0323     		mov	r3, #3
 580 0008 1340     		and	r3, r2
 581 000a 012B     		cmp	r3, #1
 582 000c 0FD0     		beq	.L46
 583 000e 002B     		cmp	r3, #0
 584 0010 07D0     		beq	.L45
 585 0012 022B     		cmp	r3, #2
 586 0014 13D1     		bne	.L43
 279:main.c        ****   {
 280:main.c        ****     case 0://on
 281:main.c        ****       pfpixel[loc]|=fnmask;
 282:main.c        ****       return;
 283:main.c        ****     case 1://off
 284:main.c        ****       pfpixel[loc]&=~fnmask;
 285:main.c        ****       return;
 286:main.c        ****     case 2://flip
 287:main.c        ****       pfpixel[loc]^=fnmask;
 587              		.loc 1 287 0
 588 0016 0B4B     		ldr	r3, .L49+4
 589 0018 1B68     		ldr	r3, [r3]
 590 001a 1818     		add	r0, r3, r0
 591              	.LVL45:
 592 001c 0378     		ldrb	r3, [r0]
 593 001e 5940     		eor	r1, r3
 594              	.LVL46:
 595 0020 0CE0     		b	.L48
 596              	.LVL47:
 597              	.L45:
 281:main.c        ****       pfpixel[loc]|=fnmask;
 598              		.loc 1 281 0
 599 0022 084B     		ldr	r3, .L49+4
 600 0024 1B68     		ldr	r3, [r3]
 601 0026 1818     		add	r0, r3, r0
 602              	.LVL48:
 603 0028 0378     		ldrb	r3, [r0]
 604 002a 1943     		orr	r1, r3
 605              	.LVL49:
 606 002c 06E0     		b	.L48
 607              	.LVL50:
 608              	.L46:
 609              	.LBB16:
 610              	.LBB17:
 284:main.c        ****       pfpixel[loc]&=~fnmask;
 611              		.loc 1 284 0
 612 002e 054B     		ldr	r3, .L49+4
 613 0030 1B68     		ldr	r3, [r3]
 614 0032 1818     		add	r0, r3, r0
 615              	.LVL51:
 616 0034 0378     		ldrb	r3, [r0]
 617 0036 8B43     		bic	r3, r1
 618 0038 0370     		strb	r3, [r0]
 619 003a 00E0     		b	.L43
 620              	.LVL52:
 621              	.L48:
 622              	.LBE17:
 623              	.LBE16:
 624              		.loc 1 287 0
ARM GAS  main.s 			page 17


 625 003c 0170     		strb	r1, [r0]
 626              	.L43:
 288:main.c        ****       return;
 289:main.c        ****     default://reserved (for what?)
 290:main.c        ****       break;
 291:main.c        ****   }
 292:main.c        **** }
 627              		.loc 1 292 0
 628              		@ sp needed for prologue
 629 003e 7047     		bx	lr
 630              	.L50:
 631              		.align	2
 632              	.L49:
 633 0040 00000000 		.word	.LANCHOR0
 634 0044 00000000 		.word	pfpixel
 635              		.cfi_endproc
 636              	.LFE10:
 638              		.section	.text.startup.main,"ax",%progbits
 639              		.align	1
 640              		.global	main
 641              		.code	16
 642              		.thumb_func
 644              	main:
 645              	.LFB11:
 293:main.c        ****
 294:main.c        **** // main() is what gets called when you store 0xFF into DPC+ register CALLFUNCTION in your 6507 code
 295:main.c        **** int main()
 296:main.c        **** {
 646              		.loc 1 296 0
 647              		.cfi_startproc
 648              	.LVL53:
 649 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 650              	.LCFI7:
 651              		.cfi_def_cfa_offset 20
 652              		.cfi_offset 4, -20
 653              		.cfi_offset 5, -16
 654              		.cfi_offset 6, -12
 655              		.cfi_offset 7, -8
 656              		.cfi_offset 14, -4
 657 0002 91B0     		sub	sp, sp, #68
 658              	.LCFI8:
 659              		.cfi_def_cfa_offset 88
 297:main.c        ****
 298:main.c        ****   int i;
 299:main.c        ****
 300:main.c        ****   // REVENG - moving the the scope of these variables saved a *lot* of space.
 301:main.c        ****   int temp2;
 302:main.c        ****   int temp3;
 303:main.c        ****   int Gfxindex;
 304:main.c        ****   unsigned char *HMdiv=(unsigned char *)(0xc00+0x1000);
 305:main.c        ****   const unsigned char setbyte[32]=
 660              		.loc 1 305 0
 661 0004 9049     		ldr	r1, .L107
 662 0006 2022     		mov	r2, #32
 663 0008 08A8     		add	r0, sp, #32
 664 000a FFF7FEFF 		bl	memcpy
 665              	.LVL54:
ARM GAS  main.s 			page 18


 306:main.c        **** 	{0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
 307:main.c        **** 	 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
 308:main.c        **** 	 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
 309:main.c        **** 	 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
 310:main.c        ****
 311:main.c        ****   fetcheraddr=flashdata+fetcher_address_table[0];
 666              		.loc 1 311 0
 667 000e 8F4B     		ldr	r3, .L107+4
 668 0010 D869     		ldr	r0, [r3, #28]
 669 0012 5A69     		ldr	r2, [r3, #20]
 670 0014 0188     		ldrh	r1, [r0]
 671 0016 5118     		add	r1, r2, r1
 672 0018 8D4A     		ldr	r2, .L107+8
 312:main.c        ****
 313:main.c        ****   // REVENG - preindex these to save some space...
 314:main.c        ****   unsigned char C_function1=C_function[1];
 673              		.loc 1 314 0
 674 001a 9E69     		ldr	r6, [r3, #24]
 311:main.c        ****   fetcheraddr=flashdata+fetcher_address_table[0];
 675              		.loc 1 311 0
 676 001c 1160     		str	r1, [r2]
 677              		.loc 1 314 0
 678 001e 7478     		ldrb	r4, [r6, #1]
 315:main.c        ****   unsigned char C_function2=C_function[2];
 316:main.c        ****   unsigned char C_function3=C_function[3];
 317:main.c        ****
 318:main.c        ****   switch (C_function[0]&0xFC)
 679              		.loc 1 318 0
 680 0020 3278     		ldrb	r2, [r6]
 681 0022 0321     		mov	r1, #3
 314:main.c        ****   unsigned char C_function1=C_function[1];
 682              		.loc 1 314 0
 683 0024 0194     		str	r4, [sp, #4]
 684              	.LVL55:
 315:main.c        ****   unsigned char C_function2=C_function[2];
 685              		.loc 1 315 0
 686 0026 B778     		ldrb	r7, [r6, #2]
 687              	.LVL56:
 316:main.c        ****   unsigned char C_function3=C_function[3];
 688              		.loc 1 316 0
 689 0028 F578     		ldrb	r5, [r6, #3]
 690              	.LVL57:
 691              		.loc 1 318 0
 692 002a 8A43     		bic	r2, r1
 693 002c 1C1C     		mov	r4, r3
 694 002e 102A     		cmp	r2, #16
 695 0030 68D0     		beq	.L56
 696 0032 0ED8     		bhi	.L61
 697 0034 082A     		cmp	r2, #8
 698 0036 46D0     		beq	.L66
 699 0038 0C2A     		cmp	r2, #12
 700 003a 56D0     		beq	.L55
 701 003c 042A     		cmp	r2, #4
 702 003e 00D0     		beq	.LCB629
 703 0040 C6E0     		b	.L52	@long jump
 704              	.LCB629:
 319:main.c        ****   {
ARM GAS  main.s 			page 19


 320:main.c        ****     case 4: // pfvline xpos ypos endypos function
 321:main.c        ****     {
 322:main.c        ****       pfpixel=queue+get32bitdff(C_function3>>3); // physical addy of xpos (pf)
 705              		.loc 1 322 0
 706 0042 E808     		lsr	r0, r5, #3
 707 0044 1C69     		ldr	r4, [r3, #16]
 708 0046 FFF7FEFF 		bl	get32bitdff
 709              	.LVL58:
 710 004a 824B     		ldr	r3, .L107+12
 711 004c 2418     		add	r4, r4, r0
 712 004e 1C60     		str	r4, [r3]
 713              	.LVL59:
 323:main.c        ****       for (i=C_function2;i<=C_function1;++i)
 714              		.loc 1 323 0
 715 0050 2EE0     		b	.L63
 716              	.LVL60:
 717              	.L61:
 318:main.c        ****   switch (C_function[0]&0xFC)
 718              		.loc 1 318 0
 719 0052 182A     		cmp	r2, #24
 720 0054 00D1     		bne	.LCB649
 721 0056 93E0     		b	.L58	@long jump
 722              	.LCB649:
 723 0058 23D8     		bhi	.L62
 724 005a 142A     		cmp	r2, #20
 725 005c 00D0     		beq	.LCB653
 726 005e B7E0     		b	.L52	@long jump
 727              	.LCB653:
 324:main.c        ****       {
 325:main.c        ****         on_off_flip(i,setbyte[C_function3]);
 326:main.c        ****       }
 327:main.c        ****       return;
 328:main.c        ****     }
 329:main.c        ****     case 8: // pfhline
 330:main.c        ****     {
 331:main.c        ****       for (i=C_function3;i<=C_function1;++i)
 332:main.c        ****       {
 333:main.c        ****         pfpixel=queue+get32bitdff(i>>3); // physical addy of xpos (pf)
 334:main.c        ****         on_off_flip(C_function2,setbyte[i]);
 335:main.c        ****       }
 336:main.c        ****       return;
 337:main.c        ****     }
 338:main.c        ****     case 12: // pfpixel
 339:main.c        ****     {
 340:main.c        ****       pfpixel=queue+get32bitdff(C_function3>>3); // physical addy of xpos (pf)
 341:main.c        ****       on_off_flip(C_function2,setbyte[C_function3]);
 342:main.c        ****       return;
 343:main.c        ****     }
 344:main.c        ****     case 16: // zero-fill
 345:main.c        ****     {
 346:main.c        ****       my_memset(RIOT+player1pointerlo,0,4096-0x1a8-player1pointerlo);
 347:main.c        ****       return;
 348:main.c        ****     }
 349:main.c        ****     case 20: // collision check
 350:main.c        ****     {
 351:main.c        ****       // takes virtual sprite, returns coll
 352:main.c        ****       // syntax: sprite[1], sprite[2] (missiles, ball not yet, pf done another way)
ARM GAS  main.s 			page 20


 353:main.c        ****       // draw sprites in virtual area
 354:main.c        ****       C_function[3]=0;
 728              		.loc 1 354 0
 729 0060 0022     		mov	r2, #0
 730 0062 F270     		strb	r2, [r6, #3]
 731              	.LVL61:
 355:main.c        ****       temp2=0;
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 732              		.loc 1 356 0
 733 0064 DA68     		ldr	r2, [r3, #12]
 357:main.c        ****       {
 358:main.c        ****         if ((i>=RIOT[player0y+C_function1]) && (i<RIOT[player0y+C_function1]+RIOT[player0height+C_f
 359:main.c        **** 	{
 360:main.c        ****
 361:main.c        ****           temp3=RIOT[player0x+C_function2]-RIOT[player0x+C_function1]+7; //-7 to +7 -> 0 to 14
 362:main.c        ****           if (temp3<15)
 363:main.c        **** 	  {
 364:main.c        ****             temp2=((flashdata[(RIOT[player0pointerhi+C_function2*2]<<8)+RIOT[player0pointerlo+C_fun
 734              		.loc 1 364 0
 735 0066 5B69     		ldr	r3, [r3, #20]
 736 0068 0493     		str	r3, [sp, #16]
 737 006a 7B00     		lsl	r3, r7, #1
 738 006c 3933     		add	r3, r3, #57
 739 006e D318     		add	r3, r2, r3
 740 0070 0393     		str	r3, [sp, #12]
 741 0072 3B1C     		mov	r3, r7
 742 0074 1C33     		add	r3, r3, #28
 365:main.c        ****                 & ((flashdata[(RIOT[player0pointerhi+C_function1*2]<<8)+RIOT[player0pointerlo+C_fun
 743              		.loc 1 365 0
 744 0076 019E     		ldr	r6, [sp, #4]
 745              	.LVL62:
 364:main.c        ****             temp2=((flashdata[(RIOT[player0pointerhi+C_function2*2]<<8)+RIOT[player0pointerlo+C_fun
 746              		.loc 1 364 0
 747 0078 5B00     		lsl	r3, r3, #1
 748 007a D318     		add	r3, r2, r3
 749 007c 0593     		str	r3, [sp, #20]
 750              		.loc 1 365 0
 751 007e 7300     		lsl	r3, r6, #1
 752 0080 3933     		add	r3, r3, #57
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 753              		.loc 1 356 0
 754 0082 D119     		add	r1, r2, r7
 755              		.loc 1 365 0
 756 0084 D318     		add	r3, r2, r3
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 757              		.loc 1 356 0
 758 0086 0C7D     		ldrb	r4, [r1, #20]
 759              		.loc 1 365 0
 760 0088 0693     		str	r3, [sp, #24]
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 761              		.loc 1 356 0
 762 008a 0131     		add	r1, r1, #1
 763              		.loc 1 365 0
 764 008c 331C     		mov	r3, r6
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 765              		.loc 1 356 0
 766 008e C97F     		ldrb	r1, [r1, #31]
ARM GAS  main.s 			page 21


 767              		.loc 1 365 0
 768 0090 1C33     		add	r3, r3, #28
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 769              		.loc 1 356 0
 770 0092 A446     		mov	ip, r4
 771              	.LVL63:
 772              		.loc 1 365 0
 773 0094 5B00     		lsl	r3, r3, #1
 774 0096 D318     		add	r3, r2, r3
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 775              		.loc 1 356 0
 776 0098 6144     		add	r1, r1, ip
 777              		.loc 1 365 0
 778 009a 0793     		str	r3, [sp, #28]
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 779              		.loc 1 356 0
 780 009c 0291     		str	r1, [sp, #8]
 781 009e 231C     		mov	r3, r4
 782 00a0 3BE0     		b	.L69
 783              	.LVL64:
 784              	.L62:
 318:main.c        ****   switch (C_function[0]&0xFC)
 785              		.loc 1 318 0
 786 00a2 1C2A     		cmp	r2, #28
 787 00a4 7CD0     		beq	.L59
 788 00a6 202A     		cmp	r2, #32
 789 00a8 00D0     		beq	.LCB701
 790 00aa 91E0     		b	.L52	@long jump
 791              	.LCB701:
 366:main.c        **** 	  }
 367:main.c        **** 	  if (temp2)
 368:main.c        **** 	  {
 369:main.c        **** 	    C_function[3]=255;
 370:main.c        **** 	    return;
 371:main.c        **** 	  }
 372:main.c        **** 	}
 373:main.c        ****       }
 374:main.c        ****       return;
 375:main.c        ****     }
 376:main.c        ****     case 24: // REVENG - pfread
 377:main.c        ****     {
 378:main.c        ****       pfpixel=queue+get32bitdff(C_function1>>3); // physical addy of xpos (pf)
 379:main.c        ****       C_function[3]=(!(pfpixel[C_function2]&setbyte[C_function1]));
 380:main.c        ****       return;
 381:main.c        ****     }
 382:main.c        ****     case 28: // REVENG - pfclear
 383:main.c        ****     {
 384:main.c        ****       my_memset(queue+get32bitdff(0),C_function1,1024);
 385:main.c        ****       return;
 386:main.c        ****     }
 387:main.c        ****     case 32: // REVENG - pfscroll
 388:main.c        ****     {
 389:main.c        ****       for(temp3=C_function2;temp3<C_function3;temp3++)
 792              		.loc 1 389 0
 793 00ac 3E1C     		mov	r6, r7
 794              	.LVL65:
 795 00ae 82E0     		b	.L72
ARM GAS  main.s 			page 22


 796              	.LVL66:
 797              	.L63:
 323:main.c        ****       for (i=C_function2;i<=C_function1;++i)
 798              		.loc 1 323 0 discriminator 1
 799 00b0 019C     		ldr	r4, [sp, #4]
 800 00b2 A742     		cmp	r7, r4
 801 00b4 00DD     		ble	.LCB717
 802 00b6 29E2     		b	.L101	@long jump
 803              	.LCB717:
 804              	.L64:
 325:main.c        ****         on_off_flip(i,setbyte[C_function3]);
 805              		.loc 1 325 0 discriminator 2
 806 00b8 08AE     		add	r6, sp, #32
 807 00ba 381C     		mov	r0, r7
 808 00bc 715D     		ldrb	r1, [r6, r5]
 809 00be FFF7FEFF 		bl	on_off_flip
 810              	.LVL67:
 323:main.c        ****       for (i=C_function2;i<=C_function1;++i)
 811              		.loc 1 323 0 discriminator 2
 812 00c2 0137     		add	r7, r7, #1
 813              	.LVL68:
 814 00c4 F4E7     		b	.L63
 815              	.LVL69:
 816              	.L66:
 331:main.c        ****       for (i=C_function3;i<=C_function1;++i)
 817              		.loc 1 331 0 discriminator 1
 818 00c6 019E     		ldr	r6, [sp, #4]
 819 00c8 B542     		cmp	r5, r6
 820 00ca 00DD     		ble	.LCB738
 821 00cc 1EE2     		b	.L101	@long jump
 822              	.LCB738:
 823              	.L67:
 333:main.c        ****         pfpixel=queue+get32bitdff(i>>3); // physical addy of xpos (pf)
 824              		.loc 1 333 0 discriminator 2
 825 00ce E810     		asr	r0, r5, #3
 826 00d0 FFF7FEFF 		bl	get32bitdff
 827              	.LVL70:
 828 00d4 2669     		ldr	r6, [r4, #16]
 829 00d6 5F4B     		ldr	r3, .L107+12
 830 00d8 3618     		add	r6, r6, r0
 831 00da 1E60     		str	r6, [r3]
 334:main.c        ****         on_off_flip(C_function2,setbyte[i]);
 832              		.loc 1 334 0 discriminator 2
 833 00dc 08AE     		add	r6, sp, #32
 834 00de 715D     		ldrb	r1, [r6, r5]
 835 00e0 381C     		mov	r0, r7
 836 00e2 FFF7FEFF 		bl	on_off_flip
 837              	.LVL71:
 331:main.c        ****       for (i=C_function3;i<=C_function1;++i)
 838              		.loc 1 331 0 discriminator 2
 839 00e6 0135     		add	r5, r5, #1
 840              	.LVL72:
 841 00e8 EDE7     		b	.L66
 842              	.LVL73:
 843              	.L55:
 340:main.c        ****       pfpixel=queue+get32bitdff(C_function3>>3); // physical addy of xpos (pf)
 844              		.loc 1 340 0
ARM GAS  main.s 			page 23


 845 00ea E808     		lsr	r0, r5, #3
 846 00ec 1C69     		ldr	r4, [r3, #16]
 847 00ee FFF7FEFF 		bl	get32bitdff
 848              	.LVL74:
 849 00f2 584B     		ldr	r3, .L107+12
 850 00f4 2418     		add	r4, r4, r0
 851 00f6 1C60     		str	r4, [r3]
 341:main.c        ****       on_off_flip(C_function2,setbyte[C_function3]);
 852              		.loc 1 341 0
 853 00f8 08A8     		add	r0, sp, #32
 854 00fa 415D     		ldrb	r1, [r0, r5]
 855 00fc 381C     		mov	r0, r7
 856 00fe FFF7FEFF 		bl	on_off_flip
 857              	.LVL75:
 858 0102 03E2     		b	.L101
 859              	.LVL76:
 860              	.L56:
 346:main.c        ****       my_memset(RIOT+player1pointerlo,0,4096-0x1a8-player1pointerlo);
 861              		.loc 1 346 0
 862 0104 D868     		ldr	r0, [r3, #12]
 863 0106 0021     		mov	r1, #0
 864 0108 3A30     		add	r0, r0, #58
 865 010a 534A     		ldr	r2, .L107+16
 866 010c 50E0     		b	.L102
 867              	.LVL77:
 868              	.L71:
 358:main.c        ****         if ((i>=RIOT[player0y+C_function1]) && (i<RIOT[player0y+C_function1]+RIOT[player0height+C_f
 869              		.loc 1 358 0
 870 010e 019D     		ldr	r5, [sp, #4]
 871 0110 5419     		add	r4, r2, r5
 872 0112 217D     		ldrb	r1, [r4, #20]
 873 0114 8B42     		cmp	r3, r1
 874 0116 04DA     		bge	.L103
 875              	.LVL78:
 876              	.L70:
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 877              		.loc 1 356 0
 878 0118 0133     		add	r3, r3, #1
 879              	.LVL79:
 880              	.L69:
 356:main.c        ****       for (i=RIOT[player0y+C_function2];i<RIOT[player0y+C_function2]+RIOT[player0height+C_function2
 881              		.loc 1 356 0 is_stmt 0 discriminator 1
 882 011a 029C     		ldr	r4, [sp, #8]
 883 011c A342     		cmp	r3, r4
 884 011e F6DB     		blt	.L71
 885 0120 F4E1     		b	.L101
 886              	.L103:
 358:main.c        ****         if ((i>=RIOT[player0y+C_function1]) && (i<RIOT[player0y+C_function1]+RIOT[player0height+C_f
 887              		.loc 1 358 0 is_stmt 1 discriminator 1
 888 0122 601C     		add	r0, r4, #1
 889 0124 C07F     		ldrb	r0, [r0, #31]
 890 0126 0818     		add	r0, r1, r0
 891 0128 8342     		cmp	r3, r0
 892 012a F5DA     		bge	.L70
 361:main.c        ****           temp3=RIOT[player0x+C_function2]-RIOT[player0x+C_function1]+7; //-7 to +7 -> 0 to 14
 893              		.loc 1 361 0
 894 012c D019     		add	r0, r2, r7
ARM GAS  main.s 			page 24


 895 012e 807A     		ldrb	r0, [r0, #10]
 896 0130 A47A     		ldrb	r4, [r4, #10]
 897 0132 001B     		sub	r0, r0, r4
 898 0134 0730     		add	r0, r0, #7
 899              	.LVL80:
 362:main.c        ****           if (temp3<15)
 900              		.loc 1 362 0
 901 0136 0E28     		cmp	r0, #14
 902 0138 EEDC     		bgt	.L70
 364:main.c        ****             temp2=((flashdata[(RIOT[player0pointerhi+C_function2*2]<<8)+RIOT[player0pointerlo+C_fun
 903              		.loc 1 364 0
 904 013a 039E     		ldr	r6, [sp, #12]
 905 013c 3578     		ldrb	r5, [r6]
 906 013e 059E     		ldr	r6, [sp, #20]
 907 0140 3478     		ldrb	r4, [r6]
 908 0142 2D02     		lsl	r5, r5, #8
 909 0144 2C19     		add	r4, r5, r4
 910 0146 049E     		ldr	r6, [sp, #16]
 911 0148 6546     		mov	r5, ip
 912 014a E418     		add	r4, r4, r3
 913 014c 641B     		sub	r4, r4, r5
 914 014e 3419     		add	r4, r6, r4
 915 0150 2478     		ldrb	r4, [r4]
 916 0152 0094     		str	r4, [sp]
 365:main.c        ****                 & ((flashdata[(RIOT[player0pointerhi+C_function1*2]<<8)+RIOT[player0pointerlo+C_fun
 917              		.loc 1 365 0
 918 0154 069C     		ldr	r4, [sp, #24]
 919 0156 2678     		ldrb	r6, [r4]
 920 0158 079C     		ldr	r4, [sp, #28]
 921 015a 2578     		ldrb	r5, [r4]
 922 015c 3602     		lsl	r6, r6, #8
 923 015e 7519     		add	r5, r6, r5
 924 0160 ED18     		add	r5, r5, r3
 925 0162 049E     		ldr	r6, [sp, #16]
 926 0164 6D1A     		sub	r5, r5, r1
 927 0166 7519     		add	r5, r6, r5
 928 0168 2978     		ldrb	r1, [r5]
 929              	.LVL81:
 930 016a 8140     		lsl	r1, r1, r0
 931              	.LVL82:
 932 016c 081C     		mov	r0, r1
 933              	.LVL83:
 364:main.c        ****             temp2=((flashdata[(RIOT[player0pointerhi+C_function2*2]<<8)+RIOT[player0pointerlo+C_fun
 934              		.loc 1 364 0
 935 016e 0099     		ldr	r1, [sp]
 936 0170 CC01     		lsl	r4, r1, #7
 367:main.c        **** 	  if (temp2)
 937              		.loc 1 367 0
 938 0172 0442     		tst	r4, r0
 939 0174 D0D0     		beq	.L70
 369:main.c        **** 	    C_function[3]=255;
 940              		.loc 1 369 0
 941 0176 354B     		ldr	r3, .L107+4
 942              	.LVL84:
 943 0178 9B69     		ldr	r3, [r3, #24]
 944 017a FF22     		mov	r2, #255
 945              	.LVL85:
ARM GAS  main.s 			page 25


 946 017c DA70     		strb	r2, [r3, #3]
 947 017e C5E1     		b	.L101
 948              	.LVL86:
 949              	.L58:
 378:main.c        ****       pfpixel=queue+get32bitdff(C_function1>>3); // physical addy of xpos (pf)
 950              		.loc 1 378 0
 951 0180 019D     		ldr	r5, [sp, #4]
 952 0182 E808     		lsr	r0, r5, #3
 953 0184 1C69     		ldr	r4, [r3, #16]
 954 0186 FFF7FEFF 		bl	get32bitdff
 955              	.LVL87:
 956 018a 324B     		ldr	r3, .L107+12
 957 018c 2018     		add	r0, r4, r0
 958 018e 1860     		str	r0, [r3]
 379:main.c        ****       C_function[3]=(!(pfpixel[C_function2]&setbyte[C_function1]));
 959              		.loc 1 379 0
 960 0190 C35D     		ldrb	r3, [r0, r7]
 961 0192 08A8     		add	r0, sp, #32
 962 0194 425D     		ldrb	r2, [r0, r5]
 963 0196 1340     		and	r3, r2
 964 0198 5A42     		neg	r2, r3
 965 019a 5341     		adc	r3, r3, r2
 966 019c F370     		strb	r3, [r6, #3]
 967 019e B5E1     		b	.L101
 968              	.LVL88:
 969              	.L59:
 384:main.c        ****       my_memset(queue+get32bitdff(0),C_function1,1024);
 970              		.loc 1 384 0
 971 01a0 0020     		mov	r0, #0
 972 01a2 1C69     		ldr	r4, [r3, #16]
 973 01a4 FFF7FEFF 		bl	get32bitdff
 974              	.LVL89:
 975 01a8 8022     		mov	r2, #128
 976 01aa 0199     		ldr	r1, [sp, #4]
 977 01ac 2018     		add	r0, r4, r0
 978 01ae D200     		lsl	r2, r2, #3
 979              	.L102:
 980 01b0 FFF7FEFF 		bl	my_memset
 981              	.LVL90:
 982 01b4 AAE1     		b	.L101
 983              	.LVL91:
 984              	.L72:
 985              		.loc 1 389 0 discriminator 1
 986 01b6 AE42     		cmp	r6, r5
 987 01b8 00DB     		blt	.LCB931
 988 01ba A7E1     		b	.L101	@long jump
 989              	.LCB931:
 990              	.L73:
 390:main.c        ****         memscroll(queue+get32bitdff(temp3),C_function1);
 991              		.loc 1 390 0 discriminator 2
 992 01bc 301C     		mov	r0, r6
 993 01be FFF7FEFF 		bl	get32bitdff
 994              	.LVL92:
 995 01c2 2769     		ldr	r7, [r4, #16]
 996 01c4 0199     		ldr	r1, [sp, #4]
 997 01c6 3818     		add	r0, r7, r0
 998 01c8 FFF7FEFF 		bl	memscroll
ARM GAS  main.s 			page 26


 999              	.LVL93:
 389:main.c        ****       for(temp3=C_function2;temp3<C_function3;temp3++)
 1000              		.loc 1 389 0 discriminator 2
 1001 01cc 0136     		add	r6, r6, #1
 1002              	.LVL94:
 1003 01ce F2E7     		b	.L72
 1004              	.LVL95:
 1005              	.L52:
 391:main.c        ****       return;
 392:main.c        ****     }
 393:main.c        ****
 394:main.c        ****   default: // everything else
 395:main.c        ****    break;
 396:main.c        ****   }
 397:main.c        ****
 398:main.c        ****   //REVENG - passed the sprite max as a parameter instead
 399:main.c        ****   maxsprites=C_function1;
 1006              		.loc 1 399 0
 1007 01d0 6946     		mov	r1, sp
 1008 01d2 224A     		ldr	r2, .L107+20
 1009 01d4 0979     		ldrb	r1, [r1, #4]
 1010 01d6 1170     		strb	r1, [r2]
 1011              	.LVL96:
 400:main.c        ****
 401:main.c        ****   for (i=0;i<maxsprites;i++)
 1012              		.loc 1 401 0
 1013 01d8 0023     		mov	r3, #0
 1014              	.LVL97:
 1015              	.L74:
 1016              		.loc 1 401 0 is_stmt 0 discriminator 1
 1017 01da 019D     		ldr	r5, [sp, #4]
 1018 01dc AB42     		cmp	r3, r5
 1019 01de 05DA     		bge	.L104
 1020              	.L75:
 402:main.c        ****   {
 403:main.c        ****     myGfxIndex[i]=spritesort[i];
 1021              		.loc 1 403 0 is_stmt 1 discriminator 2
 1022 01e0 221C     		mov	r2, r4
 1023 01e2 2032     		add	r2, r2, #32
 1024 01e4 9A5C     		ldrb	r2, [r3, r2]
 1025 01e6 E254     		strb	r2, [r4, r3]
 401:main.c        ****   for (i=0;i<maxsprites;i++)
 1026              		.loc 1 401 0 discriminator 2
 1027 01e8 0133     		add	r3, r3, #1
 1028              	.LVL98:
 1029 01ea F6E7     		b	.L74
 1030              	.L104:
 404:main.c        ****   }
 405:main.c        **** //loop
 406:main.c        ****   temp3=maxsprites-1;
 1031              		.loc 1 406 0
 1032 01ec 013D     		sub	r5, r5, #1
 295:main.c        **** int main()
 1033              		.loc 1 295 0
 1034 01ee 019E     		ldr	r6, [sp, #4]
 1035              	.LVL99:
 1036              		.loc 1 406 0
ARM GAS  main.s 			page 27


 1037 01f0 0495     		str	r5, [sp, #16]
 1038              	.LVL100:
 295:main.c        **** int main()
 1039              		.loc 1 295 0
 1040 01f2 251C     		mov	r5, r4
 1041              	.LVL101:
 1042 01f4 023E     		sub	r6, r6, #2
 1043              	.LVL102:
 1044 01f6 2035     		add	r5, r5, #32
 1045 01f8 AD19     		add	r5, r5, r6
 1046              	.LVL103:
 1047              	.L76:
 407:main.c        ****   temp2=maxsprites-2;
 408:main.c        ****  while (temp2>=0)
 1048              		.loc 1 408 0 discriminator 1
 1049 01fa 002E     		cmp	r6, #0
 1050 01fc 1ADB     		blt	.L81
 409:main.c        ****  {
 410:main.c        ****   switch(checkswap(spritesort[temp2+1],spritesort[temp2]))
 1051              		.loc 1 410 0
 1052 01fe 6878     		ldrb	r0, [r5, #1]
 1053 0200 2978     		ldrb	r1, [r5]
 295:main.c        **** int main()
 1054              		.loc 1 295 0
 1055 0202 771C     		add	r7, r6, #1
 1056              		.loc 1 410 0
 1057 0204 FFF7FEFF 		bl	checkswap
 1058              	.LVL104:
 1059              	.L77:
 1060 0208 0128     		cmp	r0, #1
 1061 020a 04D0     		beq	.L79
 1062 020c 0228     		cmp	r0, #2
 1063 020e 08D0     		beq	.L80
 1064 0210 0028     		cmp	r0, #0
 1065 0212 0CD0     		beq	.L78
 1066 0214 F8E7     		b	.L77
 1067              	.L79:
 411:main.c        ****   {
 412:main.c        ****     case OVERLAP:
 413:main.c        ****       temp3--;
 1068              		.loc 1 413 0
 1069 0216 0498     		ldr	r0, [sp, #16]
 1070 0218 0138     		sub	r0, r0, #1
 1071 021a 0490     		str	r0, [sp, #16]
 1072              	.LVL105:
 414:main.c        ****       shiftnumbers(temp2);
 1073              		.loc 1 414 0
 1074 021c 301C     		mov	r0, r6
 1075              	.LVL106:
 1076 021e FFF7FEFF 		bl	shiftnumbers
 1077              	.LVL107:
 1078              	.L80:
 415:main.c        ****       break;
 416:main.c        ****     case NOOVERLAP:
 417:main.c        ****       break;
 418:main.c        ****     case SKIP:
 419:main.c        ****       temp2--;
ARM GAS  main.s 			page 28


 420:main.c        ****     default:
 421:main.c        ****       continue;
 422:main.c        ****   }
 423:main.c        ****   // skipswapgfxtable
 424:main.c        ****   i=spritesort[temp2+1];
 1079              		.loc 1 424 0
 1080 0222 631C     		add	r3, r4, #1
 1081 0224 DF19     		add	r7, r3, r7
 1082 0226 FB7F     		ldrb	r3, [r7, #31]
 1083              	.LVL108:
 425:main.c        ****   spritesort[temp2+1]=spritesort[temp2];
 1084              		.loc 1 425 0
 1085 0228 2A78     		ldrb	r2, [r5]
 1086 022a FA77     		strb	r2, [r7, #31]
 426:main.c        ****   spritesort[temp2]=i;
 1087              		.loc 1 426 0
 1088 022c 2B70     		strb	r3, [r5]
 1089              	.LVL109:
 1090              	.L78:
 1091 022e 013E     		sub	r6, r6, #1
 1092 0230 013D     		sub	r5, r5, #1
 1093 0232 E2E7     		b	.L76
 1094              	.LVL110:
 1095              	.L81:
 408:main.c        ****  while (temp2>=0)
 1096              		.loc 1 408 0 discriminator 1
 1097 0234 0023     		mov	r3, #0
 1098              	.L82:
 1099              	.LVL111:
 427:main.c        ****   temp2--;
 428:main.c        ****  }
 429:main.c        ****   for (i=0;i<maxsprites;i++)
 1100              		.loc 1 429 0 discriminator 1
 1101 0236 094D     		ldr	r5, .L107+20
 1102 0238 2A78     		ldrb	r2, [r5]
 1103 023a 9342     		cmp	r3, r2
 1104 023c 10DA     		bge	.L105
 1105              	.L83:
 430:main.c        ****     RIOT[SpriteGfxIndex+i]=myGfxIndex[i];
 1106              		.loc 1 430 0 discriminator 2
 1107 023e E25C     		ldrb	r2, [r4, r3]
 1108 0240 E168     		ldr	r1, [r4, #12]
 1109 0242 CA54     		strb	r2, [r1, r3]
 429:main.c        ****   for (i=0;i<maxsprites;i++)
 1110              		.loc 1 429 0 discriminator 2
 1111 0244 0133     		add	r3, r3, #1
 1112              	.LVL112:
 1113 0246 F6E7     		b	.L82
 1114              	.L108:
 1115              		.align	2
 1116              	.L107:
 1117 0248 00000000 		.word	.LANCHOR1
 1118 024c 00000000 		.word	.LANCHOR0
 1119 0250 00000000 		.word	fetcheraddr
 1120 0254 00000000 		.word	pfpixel
 1121 0258 1E0E0000 		.word	3614
 1122 025c 00000000 		.word	maxsprites
ARM GAS  main.s 			page 29


 1123              	.L105:
 431:main.c        ****   RIOT[spritedisplay]=temp3;
 1124              		.loc 1 431 0
 1125 0260 6E46     		mov	r6, sp
 1126              	.LVL113:
 1127 0262 1020     		mov	r0, #16
 1128 0264 805D     		ldrb	r0, [r0, r6]
 1129 0266 E668     		ldr	r6, [r4, #12]
 1130 0268 7072     		strb	r0, [r6, #9]
 432:main.c        ****   // fetcher setup
 433:main.c        ****   //my_memset(queue+(dfhigh(3)<<8)+dflow(3),0,192);
 434:main.c        ****   my_memset(queue+get32bitdf(3),0,192);
 1131              		.loc 1 434 0
 1132 026a 0320     		mov	r0, #3
 1133 026c FFF7FEFF 		bl	get32bitdf
 1134              	.LVL114:
 1135 0270 2569     		ldr	r5, [r4, #16]
 1136 0272 0021     		mov	r1, #0
 1137 0274 2818     		add	r0, r5, r0
 1138 0276 C022     		mov	r2, #192
 1139 0278 FFF7FEFF 		bl	my_memset
 1140              	.LVL115:
 435:main.c        ****
 436:main.c        ****   //my_memset(queue+(dfhigh(1)<<8)+dflow(1),RIOT[COLUM1],192); // clear multiplexed sprites and fil
 437:main.c        ****   my_memset(queue+get32bitdf(1),RIOT[COLUM1],192); // clear multiplexed sprites and fill colors
 1141              		.loc 1 437 0
 1142 027c 0120     		mov	r0, #1
 1143 027e FFF7FEFF 		bl	get32bitdf
 1144              	.LVL116:
 1145 0282 E368     		ldr	r3, [r4, #12]
 1146 0284 2569     		ldr	r5, [r4, #16]
 1147 0286 3733     		add	r3, r3, #55
 1148 0288 1978     		ldrb	r1, [r3]
 1149 028a 2818     		add	r0, r5, r0
 1150 028c C022     		mov	r2, #192
 1151 028e FFF7FEFF 		bl	my_memset
 1152              	.LVL117:
 438:main.c        ****   //my_memset(queue+(dfhigh(0)<<8)+dflow(0)-1,RIOT[COLUM0],193); // fill COLUM0 colors
 439:main.c        ****   my_memset(queue+get32bitdf(0)-1,RIOT[COLUM0],193); // fill COLUM0 colors
 1153              		.loc 1 439 0
 1154 0292 0020     		mov	r0, #0
 1155 0294 FFF7FEFF 		bl	get32bitdf
 1156              	.LVL118:
 1157 0298 E368     		ldr	r3, [r4, #12]
 1158 029a 2569     		ldr	r5, [r4, #16]
 1159 029c 3633     		add	r3, r3, #54
 1160 029e 0138     		sub	r0, r0, #1
 1161 02a0 1978     		ldrb	r1, [r3]
 1162 02a2 2818     		add	r0, r5, r0
 1163 02a4 C122     		mov	r2, #193
 1164 02a6 FFF7FEFF 		bl	my_memset
 1165              	.LVL119:
 440:main.c        ****
 441:main.c        ****   // REVENG - fill color from player0, wrapping if necessary...
 442:main.c        ****   //my_memcpy(queue+(dfhigh(0)<<8)+dflow(0),
 443:main.c        ****   my_memcpy(queue+get32bitdf(0),
 1166              		.loc 1 443 0
ARM GAS  main.s 			page 30


 1167 02aa 0020     		mov	r0, #0
 1168 02ac FFF7FEFF 		bl	get32bitdf
 1169              	.LVL120:
 444:main.c        ****             flashdata+(RIOT[player0color+1]<<8)+RIOT[player0color], RIOT[player0y],
 1170              		.loc 1 444 0
 1171 02b0 E368     		ldr	r3, [r4, #12]
 1172 02b2 D97F     		ldrb	r1, [r3, #31]
 1173 02b4 9A7F     		ldrb	r2, [r3, #30]
 1174 02b6 0902     		lsl	r1, r1, #8
 1175 02b8 8918     		add	r1, r1, r2
 1176 02ba 6269     		ldr	r2, [r4, #20]
 443:main.c        ****   my_memcpy(queue+get32bitdf(0),
 1177              		.loc 1 443 0
 1178 02bc 2569     		ldr	r5, [r4, #16]
 1179              		.loc 1 444 0
 1180 02be 5118     		add	r1, r2, r1
 443:main.c        ****   my_memcpy(queue+get32bitdf(0),
 1181              		.loc 1 443 0
 1182 02c0 1A7D     		ldrb	r2, [r3, #20]
 445:main.c        ****             RIOT[player0height]);
 1183              		.loc 1 445 0
 1184 02c2 0133     		add	r3, r3, #1
 443:main.c        ****   my_memcpy(queue+get32bitdf(0),
 1185              		.loc 1 443 0
 1186 02c4 2818     		add	r0, r5, r0
 1187 02c6 DB7F     		ldrb	r3, [r3, #31]
 1188 02c8 FFF7FEFF 		bl	my_memcpy
 1189              	.LVL121:
 446:main.c        ****
 447:main.c        ****   //my_memcpy(queue+(dfhigh(2)<<8)+dflow(2),
 448:main.c        ****   my_memcpy(queue+get32bitdf(2),
 1190              		.loc 1 448 0
 1191 02cc 0220     		mov	r0, #2
 1192 02ce FFF7FEFF 		bl	get32bitdf
 1193              	.LVL122:
 449:main.c        ****             flashdata+(RIOT[player0pointerhi]<<8)+RIOT[player0pointerlo], 0,
 1194              		.loc 1 449 0
 1195 02d2 E368     		ldr	r3, [r4, #12]
 1196 02d4 1A1C     		mov	r2, r3
 1197 02d6 3932     		add	r2, r2, #57
 1198 02d8 1178     		ldrb	r1, [r2]
 1199 02da 013A     		sub	r2, r2, #1
 1200 02dc 1278     		ldrb	r2, [r2]
 1201 02de 0902     		lsl	r1, r1, #8
 448:main.c        ****   my_memcpy(queue+get32bitdf(2),
 1202              		.loc 1 448 0
 1203 02e0 2569     		ldr	r5, [r4, #16]
 1204              		.loc 1 449 0
 1205 02e2 8918     		add	r1, r1, r2
 1206 02e4 6269     		ldr	r2, [r4, #20]
 450:main.c        ****             RIOT[player0height]);
 1207              		.loc 1 450 0
 1208 02e6 0133     		add	r3, r3, #1
 449:main.c        ****             flashdata+(RIOT[player0pointerhi]<<8)+RIOT[player0pointerlo], 0,
 1209              		.loc 1 449 0
 1210 02e8 5118     		add	r1, r2, r1
 448:main.c        ****   my_memcpy(queue+get32bitdf(2),
ARM GAS  main.s 			page 31


 1211              		.loc 1 448 0
 1212 02ea DB7F     		ldrb	r3, [r3, #31]
 1213 02ec 0022     		mov	r2, #0
 1214 02ee 2818     		add	r0, r5, r0
 1215 02f0 FFF7FEFF 		bl	my_memcpy
 1216              	.LVL123:
 451:main.c        ****
 452:main.c        ****   count=0;
 1217              		.loc 1 452 0
 1218 02f4 874A     		ldr	r2, .L109
 1219 02f6 0023     		mov	r3, #0
 1220 02f8 1360     		str	r3, [r2]
 453:main.c        ****   temp4=0;
 1221              		.loc 1 453 0
 1222 02fa 874A     		ldr	r2, .L109+4
 1223 02fc 1360     		str	r3, [r2]
 1224              	.L84:
 454:main.c        ****   while (temp4 != 511)
 1225              		.loc 1 454 0 discriminator 1
 1226 02fe 864B     		ldr	r3, .L109+4
 1227 0300 864E     		ldr	r6, .L109+8
 1228 0302 1B68     		ldr	r3, [r3]
 1229 0304 864C     		ldr	r4, .L109+12
 1230 0306 B342     		cmp	r3, r6
 1231 0308 00D1     		bne	.LCB1179
 1232 030a D9E0     		b	.L106	@long jump
 1233              	.LCB1179:
 1234              	.L90:
 455:main.c        ****   {
 456:main.c        ****     Gfxindex=myGfxIndex[count];
 1235              		.loc 1 456 0
 1236 030c 814B     		ldr	r3, .L109
 1237 030e 1B68     		ldr	r3, [r3]
 1238 0310 E55C     		ldrb	r5, [r4, r3]
 1239              	.LVL124:
 457:main.c        **** //check if on screen, copy only if it is
 458:main.c        **** //    if (RIOT[player1y+Gfxindex]<175)
 459:main.c        ****   //  {
 460:main.c        ****
 461:main.c        ****  // masking: NUSIZ bit 7=on/off, NUSIZ 6=L/R
 462:main.c        ****  // appears to happen @ 0x99-0x9F
 463:main.c        ****       mask = 0xFF;
 464:main.c        ****       if (RIOT[_NUSIZ1+Gfxindex]>127)
 1240              		.loc 1 464 0
 1241 0312 E468     		ldr	r4, [r4, #12]
 463:main.c        ****       mask = 0xFF;
 1242              		.loc 1 463 0
 1243 0314 834A     		ldr	r2, .L109+16
 1244 0316 FF23     		mov	r3, #255
 1245              		.loc 1 464 0
 1246 0318 6119     		add	r1, r4, r5
 463:main.c        ****       mask = 0xFF;
 1247              		.loc 1 463 0
 1248 031a 1360     		str	r3, [r2]
 1249              		.loc 1 464 0
 1250 031c 0B1C     		mov	r3, r1
 1251 031e 2A33     		add	r3, r3, #42
ARM GAS  main.s 			page 32


 1252 0320 1B78     		ldrb	r3, [r3]
 1253 0322 1806     		lsl	r0, r3, #24
 1254 0324 12D5     		bpl	.L85
 465:main.c        ****       {
 466:main.c        ****         if (RIOT[player1x+Gfxindex]>=0x99)
 1255              		.loc 1 466 0
 1256 0326 C97A     		ldrb	r1, [r1, #11]
 1257 0328 9829     		cmp	r1, #152
 1258 032a 0FD9     		bls	.L85
 467:main.c        ****         {
 468:main.c        ****            // REVENG - modified to work with reflected sprites
 469:main.c        ****            mask=maskdata[((RIOT[_NUSIZ1+Gfxindex]&64)>>3)^((RIOT[_NUSIZ1+Gfxindex]&8)<<1)|(RIOT[pla
 1259              		.loc 1 469 0
 1260 032c 0820     		mov	r0, #8
 1261 032e 4026     		mov	r6, #64
 1262 0330 1840     		and	r0, r3
 1263 0332 3340     		and	r3, r6
 1264 0334 4000     		lsl	r0, r0, #1
 1265 0336 DB10     		asr	r3, r3, #3
 1266 0338 4340     		eor	r3, r0
 1267 033a 081C     		mov	r0, r1
 1268 033c 191C     		mov	r1, r3
 1269 033e 7A4B     		ldr	r3, .L109+20
 1270 0340 9938     		sub	r0, r0, #153
 1271 0342 0133     		add	r3, r3, #1
 1272 0344 0143     		orr	r1, r0
 1273 0346 5918     		add	r1, r3, r1
 1274 0348 CB7F     		ldrb	r3, [r1, #31]
 1275 034a 1360     		str	r3, [r2]
 1276              	.L85:
 470:main.c        ****         }
 471:main.c        ****       }
 472:main.c        ****       //my_memcpy(queue+(dfhigh(3)<<8)+dflow(3),
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1277              		.loc 1 473 0
 1278 034c 0320     		mov	r0, #3
 1279 034e FFF7FEFF 		bl	get32bitdf
 1280              	.LVL125:
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1281              		.loc 1 474 0
 1282 0352 6B00     		lsl	r3, r5, #1
 1283 0354 0393     		str	r3, [sp, #12]
 475:main.c        ****               RIOT[player1y+Gfxindex],
 1284              		.loc 1 475 0
 1285 0356 291C     		mov	r1, r5
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1286              		.loc 1 474 0
 1287 0358 E318     		add	r3, r4, r3
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1288              		.loc 1 473 0
 1289 035a 714F     		ldr	r7, .L109+12
 1290              		.loc 1 475 0
 1291 035c 1531     		add	r1, r1, #21
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1292              		.loc 1 474 0
 1293 035e 3B33     		add	r3, r3, #59
 1294              		.loc 1 475 0
ARM GAS  main.s 			page 33


 1295 0360 0191     		str	r1, [sp, #4]
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1296              		.loc 1 474 0
 1297 0362 1978     		ldrb	r1, [r3]
 1298 0364 2B1C     		mov	r3, r5
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1299              		.loc 1 473 0
 1300 0366 3E69     		ldr	r6, [r7, #16]
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1301              		.loc 1 474 0
 1302 0368 1D33     		add	r3, r3, #29
 476:main.c        ****               RIOT[player1height+Gfxindex]);
 1303              		.loc 1 476 0
 1304 036a 2A1C     		mov	r2, r5
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1305              		.loc 1 474 0
 1306 036c 5B00     		lsl	r3, r3, #1
 1307 036e 1B5D     		ldrb	r3, [r3, r4]
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1308              		.loc 1 473 0
 1309 0370 3018     		add	r0, r6, r0
 1310              		.loc 1 476 0
 1311 0372 2132     		add	r2, r2, #33
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1312              		.loc 1 473 0
 1313 0374 019E     		ldr	r6, [sp, #4]
 1314              		.loc 1 476 0
 1315 0376 0292     		str	r2, [sp, #8]
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1316              		.loc 1 474 0
 1317 0378 0902     		lsl	r1, r1, #8
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1318              		.loc 1 473 0
 1319 037a A25D     		ldrb	r2, [r4, r6]
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1320              		.loc 1 474 0
 1321 037c C918     		add	r1, r1, r3
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1322              		.loc 1 473 0
 1323 037e 029E     		ldr	r6, [sp, #8]
 474:main.c        ****               flashdata+(RIOT[player1pointerhi+Gfxindex*2]<<8)+RIOT[player1pointerlo+Gfxindex*2],
 1324              		.loc 1 474 0
 1325 0380 7B69     		ldr	r3, [r7, #20]
 1326 0382 5918     		add	r1, r3, r1
 473:main.c        ****       my_memcpy(queue+get32bitdf(3),
 1327              		.loc 1 473 0
 1328 0384 A35D     		ldrb	r3, [r4, r6]
 1329 0386 FFF7FEFF 		bl	my_memcpy
 1330              	.LVL126:
 477:main.c        ****       mask = 0xFF;
 1331              		.loc 1 477 0
 1332 038a 664B     		ldr	r3, .L109+16
 1333 038c FF24     		mov	r4, #255
 478:main.c        ****       //my_memcpy(queue+(dfhigh(1)<<8)+dflow(1),
 479:main.c        ****       my_memcpy(queue+get32bitdf(1),
 1334              		.loc 1 479 0
 1335 038e 0120     		mov	r0, #1
ARM GAS  main.s 			page 34


 477:main.c        ****       mask = 0xFF;
 1336              		.loc 1 477 0
 1337 0390 1C60     		str	r4, [r3]
 1338              		.loc 1 479 0
 1339 0392 FFF7FEFF 		bl	get32bitdf
 1340              	.LVL127:
 1341 0396 3E69     		ldr	r6, [r7, #16]
 480:main.c        ****               flashdata+(RIOT[player1color+Gfxindex*2+1]<<8)+RIOT[player1color+Gfxindex*2],
 1342              		.loc 1 480 0
 1343 0398 FB68     		ldr	r3, [r7, #12]
 479:main.c        ****       my_memcpy(queue+get32bitdf(1),
 1344              		.loc 1 479 0
 1345 039a 3018     		add	r0, r6, r0
 1346              		.loc 1 480 0
 1347 039c 039E     		ldr	r6, [sp, #12]
 1348 039e 9A19     		add	r2, r3, r6
 1349 03a0 4D32     		add	r2, r2, #77
 1350 03a2 2635     		add	r5, r5, #38
 1351              	.LVL128:
 1352 03a4 1178     		ldrb	r1, [r2]
 1353 03a6 6D00     		lsl	r5, r5, #1
 1354              	.LVL129:
 1355 03a8 EA5C     		ldrb	r2, [r5, r3]
 1356 03aa 0902     		lsl	r1, r1, #8
 479:main.c        ****       my_memcpy(queue+get32bitdf(1),
 1357              		.loc 1 479 0
 1358 03ac 019D     		ldr	r5, [sp, #4]
 1359 03ae 029E     		ldr	r6, [sp, #8]
 1360              		.loc 1 480 0
 1361 03b0 8918     		add	r1, r1, r2
 1362 03b2 7A69     		ldr	r2, [r7, #20]
 1363 03b4 5118     		add	r1, r2, r1
 479:main.c        ****       my_memcpy(queue+get32bitdf(1),
 1364              		.loc 1 479 0
 1365 03b6 5A5D     		ldrb	r2, [r3, r5]
 1366 03b8 9B5D     		ldrb	r3, [r3, r6]
 1367 03ba FFF7FEFF 		bl	my_memcpy
 1368              	.LVL130:
 481:main.c        **** 	      RIOT[player1y+Gfxindex],
 482:main.c        ****               RIOT[player1height+Gfxindex]);
 483:main.c        ****     //}
 484:main.c        ****     temp5=temp4;
 1369              		.loc 1 484 0
 1370 03be 564E     		ldr	r6, .L109+4
 1371 03c0 5A4D     		ldr	r5, .L109+24
 1372 03c2 3068     		ldr	r0, [r6]
 485:main.c        ****     temp4=(RIOT[player1y+Gfxindex]+RIOT[player1height+Gfxindex])&255; // REVENG - &255 to allow for
 1373              		.loc 1 485 0
 1374 03c4 019A     		ldr	r2, [sp, #4]
 484:main.c        ****     temp5=temp4;
 1375              		.loc 1 484 0
 1376 03c6 2860     		str	r0, [r5]
 1377              		.loc 1 485 0
 1378 03c8 FB68     		ldr	r3, [r7, #12]
 1379 03ca 0298     		ldr	r0, [sp, #8]
 1380 03cc 995C     		ldrb	r1, [r3, r2]
 1381 03ce 1A5C     		ldrb	r2, [r3, r0]
ARM GAS  main.s 			page 35


 1382 03d0 8A18     		add	r2, r1, r2
 1383 03d2 1440     		and	r4, r2
 1384 03d4 3460     		str	r4, [r6]
 486:main.c        ****     Gfxindex=myGfxIndex[count+1];
 1385              		.loc 1 486 0
 1386 03d6 4F4C     		ldr	r4, .L109
 1387 03d8 2168     		ldr	r1, [r4]
 1388 03da 0191     		str	r1, [sp, #4]
 1389 03dc 7A18     		add	r2, r7, r1
 1390 03de 5278     		ldrb	r2, [r2, #1]
 1391 03e0 0292     		str	r2, [sp, #8]
 1392              	.LVL131:
 487:main.c        ****     if ((count == temp3) || (RIOT[player1y+Gfxindex]>175) )
 1393              		.loc 1 487 0
 1394 03e2 049A     		ldr	r2, [sp, #16]
 1395              	.LVL132:
 1396 03e4 9142     		cmp	r1, r2
 1397 03e6 04D0     		beq	.L86
 1398              		.loc 1 487 0 is_stmt 0 discriminator 1
 1399 03e8 0298     		ldr	r0, [sp, #8]
 1400 03ea 1B18     		add	r3, r3, r0
 1401 03ec 5B7D     		ldrb	r3, [r3, #21]
 1402 03ee AF2B     		cmp	r3, #175
 1403 03f0 03D9     		bls	.L87
 1404              	.L86:
 488:main.c        ****     {
 489:main.c        ****       temp4=511;
 1405              		.loc 1 489 0 is_stmt 1
 1406 03f2 4A49     		ldr	r1, .L109+8
 490:main.c        ****       temp5=0;
 1407              		.loc 1 490 0
 1408 03f4 0023     		mov	r3, #0
 489:main.c        ****       temp4=511;
 1409              		.loc 1 489 0
 1410 03f6 3160     		str	r1, [r6]
 1411              		.loc 1 490 0
 1412 03f8 2B60     		str	r3, [r5]
 1413              	.L87:
 491:main.c        ****     }
 492:main.c        ****
 493:main.c        ****     // REVENG - it looks like if vertical positioning is tight, cumulative round-off
 494:main.c        ****     // can occur and eventually coarse positioning will happen during sprite display...
 495:main.c        ****      //queue[(dfhigh(4)<<8)+dflow(4)+count]=(temp4-temp5-(count>>1))>>1;
 496:main.c        ****      queue[get32bitdf(4)+count]=(temp4-temp5-(count>>1))>>1;
 1414              		.loc 1 496 0
 1415 03fa 3A69     		ldr	r2, [r7, #16]
 1416 03fc 0420     		mov	r0, #4
 1417 03fe 0392     		str	r2, [sp, #12]
 1418 0400 FFF7FEFF 		bl	get32bitdf
 1419              	.LVL133:
 1420 0404 019B     		ldr	r3, [sp, #4]
 1421 0406 3268     		ldr	r2, [r6]
 1422 0408 C018     		add	r0, r0, r3
 1423 040a 019E     		ldr	r6, [sp, #4]
 1424 040c 2B68     		ldr	r3, [r5]
 1425 040e 7510     		asr	r5, r6, #1
 1426 0410 D31A     		sub	r3, r2, r3
ARM GAS  main.s 			page 36


 1427 0412 5D1B     		sub	r5, r3, r5
 1428 0414 0399     		ldr	r1, [sp, #12]
 1429 0416 6D10     		asr	r5, r5, #1
 1430 0418 2D06     		lsl	r5, r5, #24
 1431 041a 0818     		add	r0, r1, r0
 1432 041c 2D0E     		lsr	r5, r5, #24
 1433 041e 0570     		strb	r5, [r0]
 497:main.c        ****
 498:main.c        ****     if (RIOT[player1x+Gfxindex]>159)
 1434              		.loc 1 498 0
 1435 0420 029D     		ldr	r5, [sp, #8]
 1436 0422 F868     		ldr	r0, [r7, #12]
 1437 0424 0B35     		add	r5, r5, #11
 1438 0426 4219     		add	r2, r0, r5
 1439 0428 1378     		ldrb	r3, [r2]
 1440 042a 9F2B     		cmp	r3, #159
 1441 042c 05D9     		bls	.L88
 499:main.c        ****       RIOT[player1x+Gfxindex]-=(RIOT[player1x+Gfxindex]>208)?96:160;
 1442              		.loc 1 499 0
 1443 042e A021     		mov	r1, #160
 1444 0430 D02B     		cmp	r3, #208
 1445 0432 00D9     		bls	.L89
 1446 0434 6021     		mov	r1, #96
 1447              	.L89:
 1448              		.loc 1 499 0 is_stmt 0 discriminator 3
 1449 0436 5B1A     		sub	r3, r3, r1
 1450 0438 1370     		strb	r3, [r2]
 1451              	.L88:
 500:main.c        ****     queue[get32bitdff(5)+count]=RIOT[_NUSIZ1+Gfxindex];
 1452              		.loc 1 500 0 is_stmt 1
 1453 043a 0520     		mov	r0, #5
 1454 043c FFF7FEFF 		bl	get32bitdff
 1455              	.LVL134:
 1456 0440 2168     		ldr	r1, [r4]
 1457 0442 3E69     		ldr	r6, [r7, #16]
 1458 0444 4018     		add	r0, r0, r1
 1459 0446 FA68     		ldr	r2, [r7, #12]
 1460 0448 3618     		add	r6, r6, r0
 1461 044a 0298     		ldr	r0, [sp, #8]
 1462 044c 1318     		add	r3, r2, r0
 1463 044e 2A33     		add	r3, r3, #42
 1464 0450 1B78     		ldrb	r3, [r3]
 501:main.c        ****     queue[get32bitdff(7)+count]=Hmval74(RIOT[player1x+Gfxindex]);
 1465              		.loc 1 501 0
 1466 0452 0720     		mov	r0, #7
 500:main.c        ****     queue[get32bitdff(5)+count]=RIOT[_NUSIZ1+Gfxindex];
 1467              		.loc 1 500 0
 1468 0454 3370     		strb	r3, [r6]
 1469              		.loc 1 501 0
 1470 0456 FFF7FEFF 		bl	get32bitdff
 1471              	.LVL135:
 1472 045a 2168     		ldr	r1, [r4]
 1473 045c 3E69     		ldr	r6, [r7, #16]
 1474 045e 4018     		add	r0, r0, r1
 1475 0460 FA68     		ldr	r2, [r7, #12]
 1476 0462 3018     		add	r0, r6, r0
 1477 0464 324E     		ldr	r6, .L109+28
ARM GAS  main.s 			page 37


 1478 0466 535D     		ldrb	r3, [r2, r5]
 1479 0468 3168     		ldr	r1, [r6]
 1480 046a CB18     		add	r3, r1, r3
 1481 046c 4233     		add	r3, r3, #66
 1482 046e 1B78     		ldrb	r3, [r3]
 1483 0470 0370     		strb	r3, [r0]
 502:main.c        ****     //queue[(dfhigh(5)<<8)+dflow(5)+count]=kernello(HMdiv[RIOT[player1x+Gfxindex]]);
 503:main.c        ****     queue[get32bitdf(5)+count]=kernello(HMdiv[RIOT[player1x+Gfxindex]]);
 1484              		.loc 1 503 0
 1485 0472 3A69     		ldr	r2, [r7, #16]
 1486 0474 0520     		mov	r0, #5
 1487 0476 0192     		str	r2, [sp, #4]
 1488 0478 FFF7FEFF 		bl	get32bitdf
 1489              	.LVL136:
 1490 047c 2368     		ldr	r3, [r4]
 1491 047e FA68     		ldr	r2, [r7, #12]
 1492 0480 0199     		ldr	r1, [sp, #4]
 1493 0482 C018     		add	r0, r0, r3
 1494 0484 0818     		add	r0, r1, r0
 1495 0486 535D     		ldrb	r3, [r2, r5]
 1496 0488 E021     		mov	r1, #224
 1497 048a 4901     		lsl	r1, r1, #5
 1498 048c 5B5C     		ldrb	r3, [r3, r1]
 1499 048e 3268     		ldr	r2, [r6]
 1500 0490 D35C     		ldrb	r3, [r2, r3]
 1501 0492 0370     		strb	r3, [r0]
 504:main.c        ****     //queue[(dfhigh(6)<<8)+dflow(6)+count]=kernelhi(HMdiv[RIOT[player1x+Gfxindex]]);
 505:main.c        ****     queue[get32bitdf(6)+count]=kernelhi(HMdiv[RIOT[player1x+Gfxindex]]);
 1502              		.loc 1 505 0
 1503 0494 3B69     		ldr	r3, [r7, #16]
 1504 0496 0620     		mov	r0, #6
 1505 0498 0193     		str	r3, [sp, #4]
 1506 049a FFF7FEFF 		bl	get32bitdf
 1507              	.LVL137:
 1508 049e FB68     		ldr	r3, [r7, #12]
 1509 04a0 2168     		ldr	r1, [r4]
 1510 04a2 5B5D     		ldrb	r3, [r3, r5]
 1511 04a4 019A     		ldr	r2, [sp, #4]
 1512 04a6 E025     		mov	r5, #224
 1513 04a8 4018     		add	r0, r0, r1
 1514 04aa 6D01     		lsl	r5, r5, #5
 1515 04ac 5B5D     		ldrb	r3, [r3, r5]
 1516 04ae 1018     		add	r0, r2, r0
 1517 04b0 3268     		ldr	r2, [r6]
 1518 04b2 D318     		add	r3, r2, r3
 1519 04b4 DB7A     		ldrb	r3, [r3, #11]
 1520 04b6 0370     		strb	r3, [r0]
 506:main.c        ****     count++;
 1521              		.loc 1 506 0
 1522 04b8 2368     		ldr	r3, [r4]
 1523 04ba 0133     		add	r3, r3, #1
 1524 04bc 2360     		str	r3, [r4]
 1525 04be 1EE7     		b	.L84
 1526              	.LVL138:
 1527              	.L106:
 507:main.c        ****   }
 508:main.c        ****   temp5=1;
ARM GAS  main.s 			page 38


 1528              		.loc 1 508 0
 1529 04c0 1A4B     		ldr	r3, .L109+24
 1530 04c2 0122     		mov	r2, #1
 1531 04c4 1A60     		str	r2, [r3]
 509:main.c        ****     copynybble(RIOT[score]);//+i
 1532              		.loc 1 509 0
 1533 04c6 E368     		ldr	r3, [r4, #12]
 1534 04c8 3333     		add	r3, r3, #51
 1535 04ca 1878     		ldrb	r0, [r3]
 1536 04cc FFF7FEFF 		bl	copynybble
 1537              	.LVL139:
 510:main.c        ****     copynybble(RIOT[score] >> 4);
 1538              		.loc 1 510 0
 1539 04d0 E368     		ldr	r3, [r4, #12]
 1540 04d2 3333     		add	r3, r3, #51
 1541 04d4 1878     		ldrb	r0, [r3]
 1542 04d6 0009     		lsr	r0, r0, #4
 1543 04d8 FFF7FEFF 		bl	copynybble
 1544              	.LVL140:
 511:main.c        ****     copynybble(RIOT[score2]);
 1545              		.loc 1 511 0
 1546 04dc E368     		ldr	r3, [r4, #12]
 1547 04de 3433     		add	r3, r3, #52
 1548 04e0 1878     		ldrb	r0, [r3]
 1549 04e2 FFF7FEFF 		bl	copynybble
 1550              	.LVL141:
 512:main.c        ****     copynybble(RIOT[score2] >> 4);
 1551              		.loc 1 512 0
 1552 04e6 E368     		ldr	r3, [r4, #12]
 1553 04e8 3433     		add	r3, r3, #52
 1554 04ea 1878     		ldrb	r0, [r3]
 1555 04ec 0009     		lsr	r0, r0, #4
 1556 04ee FFF7FEFF 		bl	copynybble
 1557              	.LVL142:
 513:main.c        ****     copynybble(RIOT[score3]);
 1558              		.loc 1 513 0
 1559 04f2 E368     		ldr	r3, [r4, #12]
 1560 04f4 3533     		add	r3, r3, #53
 1561 04f6 1878     		ldrb	r0, [r3]
 1562 04f8 FFF7FEFF 		bl	copynybble
 1563              	.LVL143:
 514:main.c        ****     copynybble(RIOT[score3] >> 4);
 1564              		.loc 1 514 0
 1565 04fc E368     		ldr	r3, [r4, #12]
 1566 04fe 3533     		add	r3, r3, #53
 1567 0500 1878     		ldrb	r0, [r3]
 1568 0502 0009     		lsr	r0, r0, #4
 1569 0504 FFF7FEFF 		bl	copynybble
 1570              	.LVL144:
 515:main.c        ****
 516:main.c        ****   return 0;
 1571              		.loc 1 516 0
 1572 0508 0020     		mov	r0, #0
 1573 050a FFE7     		b	.L51
 1574              	.LVL145:
 1575              	.L101:
 1576              	.L51:
ARM GAS  main.s 			page 39


 517:main.c        **** }
 1577              		.loc 1 517 0
 1578 050c 11B0     		add	sp, sp, #68
 1579              		@ sp needed for prologue
 1580 050e F0BC     		pop	{r4, r5, r6, r7}
 1581 0510 02BC     		pop	{r1}
 1582 0512 0847     		bx	r1
 1583              	.L110:
 1584              		.align	2
 1585              	.L109:
 1586 0514 00000000 		.word	count
 1587 0518 00000000 		.word	temp4
 1588 051c FF010000 		.word	511
 1589 0520 00000000 		.word	.LANCHOR0
 1590 0524 00000000 		.word	mask
 1591 0528 00000000 		.word	.LANCHOR1
 1592 052c 00000000 		.word	temp5
 1593 0530 00000000 		.word	fetcheraddr
 1594              		.cfi_endproc
 1595              	.LFE11:
 1597              		.comm	maxsprites,1,1
 1598              		.global	myGfxIndex
 1599              		.global	spritesort
 1600              		.global	maskdata
 1601              		.comm	mask,4,4
 1602              		.comm	temp5,4,4
 1603              		.comm	temp4,4,4
 1604              		.comm	count,4,4
 1605              		.comm	pfpixel,4,4
 1606              		.comm	fetcheraddr,4,4
 1607              		.global	RIOT
 1608              		.global	fetcher_address_table
 1609              		.global	C_function
 1610              		.global	queue_int
 1611              		.global	flashdata
 1612              		.global	queue
 1613              		.section	.rodata
 1614              		.set	.LANCHOR1,. + 0
 1615              	.LC0:
 1616 0000 80       		.byte	-128
 1617 0001 40       		.byte	64
 1618 0002 20       		.byte	32
 1619 0003 10       		.byte	16
 1620 0004 08       		.byte	8
 1621 0005 04       		.byte	4
 1622 0006 02       		.byte	2
 1623 0007 01       		.byte	1
 1624 0008 01       		.byte	1
 1625 0009 02       		.byte	2
 1626 000a 04       		.byte	4
 1627 000b 08       		.byte	8
 1628 000c 10       		.byte	16
 1629 000d 20       		.byte	32
 1630 000e 40       		.byte	64
 1631 000f 80       		.byte	-128
 1632 0010 80       		.byte	-128
 1633 0011 40       		.byte	64
ARM GAS  main.s 			page 40


 1634 0012 20       		.byte	32
 1635 0013 10       		.byte	16
 1636 0014 08       		.byte	8
 1637 0015 04       		.byte	4
 1638 0016 02       		.byte	2
 1639 0017 01       		.byte	1
 1640 0018 01       		.byte	1
 1641 0019 02       		.byte	2
 1642 001a 04       		.byte	4
 1643 001b 08       		.byte	8
 1644 001c 10       		.byte	16
 1645 001d 20       		.byte	32
 1646 001e 40       		.byte	64
 1647 001f 80       		.byte	-128
 1650              	maskdata:
 1651 0020 00       		.byte	0
 1652 0021 01       		.byte	1
 1653 0022 03       		.byte	3
 1654 0023 07       		.byte	7
 1655 0024 0F       		.byte	15
 1656 0025 1F       		.byte	31
 1657 0026 3F       		.byte	63
 1658 0027 7F       		.byte	127
 1659 0028 FE       		.byte	-2
 1660 0029 FC       		.byte	-4
 1661 002a F8       		.byte	-8
 1662 002b F0       		.byte	-16
 1663 002c E0       		.byte	-32
 1664 002d C0       		.byte	-64
 1665 002e 80       		.byte	-128
 1666 002f 00       		.byte	0
 1667 0030 00       		.byte	0
 1668 0031 80       		.byte	-128
 1669 0032 C0       		.byte	-64
 1670 0033 E0       		.byte	-32
 1671 0034 F0       		.byte	-16
 1672 0035 F8       		.byte	-8
 1673 0036 FC       		.byte	-4
 1674 0037 FE       		.byte	-2
 1675 0038 7F       		.byte	127
 1676 0039 3F       		.byte	63
 1677 003a 1F       		.byte	31
 1678 003b 0F       		.byte	15
 1679 003c 07       		.byte	7
 1680 003d 03       		.byte	3
 1681 003e 01       		.byte	1
 1682 003f 00       		.byte	0
 1683              		.data
 1684              		.align	2
 1685              		.set	.LANCHOR0,. + 0
 1688              	myGfxIndex:
 1689 0000 00       		.byte	0
 1690 0001 01       		.byte	1
 1691 0002 02       		.byte	2
 1692 0003 03       		.byte	3
 1693 0004 04       		.byte	4
 1694 0005 05       		.byte	5
ARM GAS  main.s 			page 41


 1695 0006 06       		.byte	6
 1696 0007 07       		.byte	7
 1697 0008 08       		.byte	8
 1698 0009 00       		.byte	0
 1699 000a 0000     		.space	2
 1702              	RIOT:
 1703 000c A80D0040 		.word	1073745320
 1706              	queue:
 1707 0010 000C0040 		.word	1073744896
 1710              	flashdata:
 1711 0014 000C0000 		.word	3072
 1714              	C_function:
 1715 0018 A40D0040 		.word	1073745316
 1718              	fetcher_address_table:
 1719 001c A06D0000 		.word	28064
 1722              	spritesort:
 1723 0020 00       		.byte	0
 1724 0021 01       		.byte	1
 1725 0022 02       		.byte	2
 1726 0023 03       		.byte	3
 1727 0024 04       		.byte	4
 1728 0025 05       		.byte	5
 1729 0026 06       		.byte	6
 1730 0027 07       		.byte	7
 1731 0028 08       		.byte	8
 1732 0029 00       		.byte	0
 1733 002a 0000     		.space	2
 1736              	queue_int:
 1737 002c 000C0040 		.word	1073744896
 1738              		.text
 1739              	.Letext0:
ARM GAS  main.s 			page 42


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
              main.s:18     .text.my_memcpy:00000000 $t
              main.s:23     .text.my_memcpy:00000000 my_memcpy
              main.s:69     .text.my_memcpy:00000024 $d
                            *COM*:00000004 mask
              main.s:74     .text.my_memset:00000000 $t
              main.s:79     .text.my_memset:00000000 my_memset
              main.s:113    .text.reverse:00000000 $t
              main.s:118    .text.reverse:00000000 reverse
              main.s:157    .text.memscroll:00000000 $t
              main.s:162    .text.memscroll:00000000 memscroll
              main.s:207    .text.get32bitdff:00000000 $t
              main.s:212    .text.get32bitdff:00000000 get32bitdff
              main.s:235    .text.get32bitdff:00000018 $d
                            *COM*:00000004 fetcheraddr
              main.s:240    .text.get32bitdf:00000000 $t
              main.s:245    .text.get32bitdf:00000000 get32bitdf
              main.s:265    .text.get32bitdf:00000010 $d
              main.s:270    .text.shiftnumbers:00000000 $t
              main.s:275    .text.shiftnumbers:00000000 shiftnumbers
              main.s:308    .text.shiftnumbers:0000001c $d
                            *COM*:00000001 maxsprites
              main.s:314    .text.checkwrap:00000000 $t
              main.s:319    .text.checkwrap:00000000 checkwrap
              main.s:351    .text.checkswap:00000000 $t
              main.s:356    .text.checkswap:00000000 checkswap
              main.s:455    .text.checkswap:00000058 $d
              main.s:460    .text.copynybble:00000000 $t
              main.s:465    .text.copynybble:00000000 copynybble
              main.s:558    .text.copynybble:00000058 $d
                            *COM*:00000004 temp5
              main.s:565    .text.on_off_flip:00000000 $t
              main.s:570    .text.on_off_flip:00000000 on_off_flip
              main.s:633    .text.on_off_flip:00000040 $d
                            *COM*:00000004 pfpixel
              main.s:639    .text.startup.main:00000000 $t
              main.s:644    .text.startup.main:00000000 main
              main.s:1117   .text.startup.main:00000248 $d
              main.s:1125   .text.startup.main:00000260 $t
              main.s:1586   .text.startup.main:00000514 $d
                            *COM*:00000004 count
                            *COM*:00000004 temp4
              main.s:1688   .data:00000000 myGfxIndex
              main.s:1722   .data:00000020 spritesort
              main.s:1650   .rodata:00000020 maskdata
              main.s:1702   .data:0000000c RIOT
              main.s:1718   .data:0000001c fetcher_address_table
              main.s:1714   .data:00000018 C_function
              main.s:1736   .data:0000002c queue_int
              main.s:1710   .data:00000014 flashdata
              main.s:1706   .data:00000010 queue
              main.s:1684   .data:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
ARM GAS  main.s 			page 43


